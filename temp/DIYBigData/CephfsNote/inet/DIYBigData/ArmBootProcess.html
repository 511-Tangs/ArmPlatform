<!DOCTYPE html>
<html lang="en">
  <head><title>Get more out of "Das U Boot" - umiddelb/armhf Wiki - GitHub</title>
  </head>

  <body class="logged-out env-production">
  <h3 class="gh-header-title instapaper_title">Get more out of "Das U Boot"</h3>
      <div class="gh-header-meta">
        leonklingele edited this page <relative-time title="Jan 1, 2017, 5:47 AM GMT+8" datetime="2016-12-31T21:47:05Z">on Jan 1, 2017</relative-time>
    <h3>Synopsis</h3>

<p>The majority of recent ARM based devices use "Das U-Boot" (u-boot) to
 load and start the Linux kernel. Many vendors focus on an end-user 
friendly u-boot configuration. If you need more flexibility, it is worth
 a deeper look into the u-boot internal structure</p>

<p>The people from the ODROID Magazine kindly published this artice in their <a href="http://forum.odroid.com/viewtopic.php?f=7&amp;t=17263">2015-11 issue</a>.</p>

<h3>What is u-boot?</h3>

<p>U-boot is a boot loader similar to <a href="http://lilo.alioth.debian.org/">lilo</a> or <a href="https://www.gnu.org/software/grub/">grub</a>, but is specifically designed for embedded devices. U-boot is maintained by <a href="http://www.denx.de/wiki/U-Boot/WebHome">denx</a>
 and published under the GNU General Public License version 2 
(GPL-2.0+). Compared to grub, u-boot doesn't offer a high level of 
selfconfiguration or end-user friendliness, but it does offer a much 
smaller footprint.</p>

<p>The most convenient way to interact with u-boot is via serial 
console. Many ARM devices offer serial access via USB, which makes it 
easy to manage console access. Just connect the serial console via USB 
to another Linux box,  and you have remote serial access to your ARM 
device. To do so, log in to your Linux box via ssh and open the serial 
connection via minicom(1):</p>

<pre>
sudo minicom -b 115200 -D /dev/ttyUSB0
</pre>

<p>Press <code>^A z</code> to open the interactive help/configuration screen, press <code>^A x</code> to exit your minicom session.</p>

<p><code>minicom</code> isn't the only terminal emulator for serial access, screen(1) and picocom(8) are popular alternatives:</p>

<pre>
sudo picocom -b 115200 /dev/ttyUSB0
</pre>

<p>Press <code>^A ^X</code> to exit your picocom session.</p>

<a name="BootProcess"></a>
<h3>The boot process</h3>

<p>When a device gets powered on, it has to go through various 
initialization stages before you see the operating system login prompt 
or desktop.</p>

<h4>Stage 1 (Secondary Program Loader / SPL)</h4>

<p>The first stage of the boot process is the Secondary Program Loader 
(SPL).  This preliminary piece of code is responsible for board 
initialization, loading the u-boot binary ("secondary program") and 
handling the control flow over to the u-boot main program.  It is device
 specific, and is often provided as a closed source binary blob by the 
SoC vendor.</p>

<p>The secondary program loader (SPL) and the u-boot binary reside in a 
special on-board flash memory region or on the first sectors of the 
uSD/eMMC card.  ODROID devices use microSD or eMMC modules for storing 
the SPL and u-boot binary. The individual disk regions are detailed in 
the disk layout and <a href="https://github.com/umiddelb/armhf/wiki/Get-more-out-of-%22Das-U-Boot%22#disk-layout-and-partitioning">partitioning section</a> below.</p>


<TABLE>
<TR><TH>Area&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <TH>&nbsp;&nbsp;<TH>ODROID-XU4
<TR><Td>SPL<Td>&nbsp;&nbsp;<Td>1 - 62
<TR><Td>U-boot executable<Td>&nbsp;&nbsp;<Td>63 - 718
<TR><Td>U-boot environment<Td>&nbsp;&nbsp;<Td>1231 - 1262
<TR><Td>1st partition<Td>&nbsp;&nbsp;<Td>3072 -
</TABLE>
<p><b>Note:</b> All numbers denote the start and the end sector</p>

<h4>Stage 2 (u-boot)</h4>

<p>At the second stage of the boot process, the u-boot main program is 
executed.  U-boot first looks for a custom environment stored at a 
reserved space on the microSD or eMMC module, or falls back to the 
compile-time default environment if needed.  At this time, you can 
interrupt the automatic boot process by pressing a key on your serial 
console, which starts an interactive u-boot shell.  The u-boot variable 
called <code>bootdelay</code> specifies the number of seconds to wait for a keypress 
before continuing automatic boot.</p>

<pre>
CPU : AMLogic S805
MEM : 1024MB (DDR3@792MHz)
BID : HKC13C0001
S/N : HKC1CC037EBCBFA4
0x0000009f
Loading U-boot...success.


U-boot-00000-geb22ea4-dirty(odroidc@eb22ea4b) (Jul 28 2015 - 22:16:46)

DRAM:  1 GiB
relocation Offset is: 2ff1c000
MMC:   eMMC: 0, SDCARD: 1
IR init is done!
vpu clk_level = 3
set vpu clk: 182150000Hz, readback: 182150000Hz(0x701)
mode = 6  vic = 4
set HDMI vic: 4
mode is: 6
viu chan = 1
config HPLL
config HPLL done
reconfig packet setting done
MMC read: dev # 0, block # 33984, count 12288 ... 12288 blocks read: OK
There is no valid bmp file at the given address
============================================================
Vendor: Man 450100 Snr 01172c20 Rev: 4.7 Prod: SDW16
            Type: Removable Hard Disk
            Capacity: 15028.0 MB = 14.6 GB (30777344 x 512)
------------------------------------------------------------
Partition     Start Sector     Num Sectors     Type
    1                 3072          524288       b
    2               527360        14680064      83
    3             15207424        15569920      83
============================================================
Net:   Meson_Ethernet
init suspend firmware done. (ret:0)
Hit Enter key to stop autoboot -- :  3 tstc enter

exit abortboot: 1
odroidc#
</pre>

<p>The automatic boot process executes a special u-boot macro called 
<code>bootcmd</code>, which loads and executes the following procedures: 
(See <a href="#BootSequence"><b>Typical boot sequence</b></a> below)</p>

<ol>
  <li>(opt.) a custom u-boot environment: <code>uEnv.txt</code></li>
  <li>(opt.) a precompiled u-boot macro: <code>boot.scr</code></li>
  <li>the kernel image, e.g. <code>uImage</code></li>
  <li>(opt.) the device tree binary, e. g. <code>meson8b_odroidc.dtb</code></li>
  <li>(opt.) the initial ramdisk, e. g. <code>uInitrd</code></li>
</ol>

<hr>
  <p> Extracted from XvisorOnRaspberryPi2.html in Xvisor/HTML directory.

  <P> <b>Note:</b> If you want to "autoboot" then you need to create a boot.scr 
   file on the root of the SD card. To do so edit a boot.cmd text file and add 
   all the commmands you want to execute automatically. For example you can put
   the following commands in the "boot.cmd" file:

<PRE>
   mmc dev 0:0
   fatload mmc 0 0x200000 uvmm.bin
   fatload mmc 0 0x800000 one_guest_vexpress-a15.dtb
   fatload mmc 0 0x2000000 udisk.img
   bootm 0x200000 0x2000000 0x800000
</PRE>

<P>   Then you can create the boot.scr file with the following command:

<PRE>
   # mkimage -C none -A arm -T script -d boot.cmd boot.scr
</PRE>
<hr>

<h4>Stage 3 (Linux kernel)</h4>

<p>The third stage is the loading of the Linux kernel.  However, before 
the Linux kernel takes control, u-boot passes a command line to the 
kernel containing essential parameters.  These parameters can be viewed 
after the operating system has booted by typing the following into a 
Terminal window:</p>

<pre>
$ cat /proc/cmdline
root=/dev/mmcblk0p2 rootwait rw console=ttyS0,115200n8 console=tty0 no_console_suspend vdaccfg=0xa000 \
logo=osd1,loaded,0x7900000,720p,full dmfc=3 cvbsmode=576cvbs hdmimode=1080p m_bpp=32 vout=hdmi disablehpd=true
</pre>

<p>The kernel initializes the hardware, mounts the root filesystem (according to the 
<code>root=...</code> kernel parameter) and passes the control flow to 
<code>/sbin/init</code>.</p>

<h4>The shortcut</h4>

<p>Hardkernel makes use of a special u-boot command called <code>cfgload</code>, which 
bypasses the ordinary boot process and provides a simplified u-boot configuration 
facility in a single file called 
<a href="https://github.com/mdrjr/5422_bootini/blob/master/boot.ini" 
target="_b">boot.ini</a>.  Configuration changes can be 
done easily by editing the <code>boot.ini</code> file, rather than modifying the u-boot 
environment, but this extension doesn't provide any access to the interactive u-boot 
shell.</p>

<p>You can boot one configuration at a time only by default. If a particular 
configuration change causes the system to hang during boot, you will need to remove 
the uSD or eMMC module from your device and revert this change by editing 
<code>boot.ini</code> on your notebook or PC.</p>

<h3>Understanding u-boot</h3>

<h4>Disk layout and partitioning</h4>

<p>Many ARM boards use a uSD/eMMC module to store the different u-boot 
components (SPL, u-boot executable, u-boot environment). In contrast to 
other devices which use flash based memory storage for this purpose 
(tablets, mobiles, ...), you cannot brick your device by an unsuccessful
 firmware update.</p>

<p>The u-boot components are stored on reserved areas of the uSD/eMMC, 
before the first partition starts (all numbers denote the start and the 
end sector):</p>
<table>
<thead>
<tr><th align="left">Area</th>
    <th align="right">&nbsp;&nbsp;ODROID-<a href="http://odroid.com/dokuwiki/doku.php?
        id=en:c1_partition_table">C1(+)</a></th>
    <th align="right">&nbsp;&nbsp;ODROID-<a href="http://odroid.com/dokuwiki/doku.php?
        id=en:c2_partition_table">C2</a></th>
    <th align="right">&nbsp;&nbsp;ODROID-<a href="http://odroid.com/dokuwiki/doku.php?
        id=en:u3_partition_table">U3</a>/<a href="http://odroid.com/dokuwiki/doku.php?
        id=en:xu3_partition_table">XU3/XU4</a></th>
    <th align="right">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://wiki.solid-run.com/doku.php?
        id=products:imx6:software:development:u-boot">CuBox-i</a></th>
    <th align="right">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.pine64.com/product">PINE64(+)</a></th>
</tr>
</thead>
<tbody>
<tr><td align="left">SPL (BL1/BL2)</td><td align="right">0 -   63</td>
    <td align="right">0 -   96</td><td align="right">1 -   62</td>
    <td align="right">1 -   83</td><td align="right">16 - 143</td>
</tr>
<tr><td align="left">U-boot executable</td><td align="right">64 - 1023</td>
    <td align="right">97 -  1431</td><td align="right">63 -  718</td>
    <td align="right">84 -  767</td><td align="right">38192 - 40959</td>
</tr>
<tr><td align="left"><strong>U-boot environment</strong></td><td align="right"><strong>1024 - 1087</strong></td>
    <td align="right"><strong>1440 - 1503</strong></td><td align="right"><strong>1231 - 1262</strong></td>
    <td align="right"><strong>768 - 783</strong></td><td align="right"><strong>file based</strong></td>
</tr>
<tr><td align="left">1st partition</td><td align="right">3072 -  ...</td>
    <td align="right">3072 -  ...</td><td align="right">3072 -  ...</td>
    <td align="right">2048 -  ...</td><td align="right">40960 - ...</td>
</tr>
</tbody>
</table>

<p>As you can see, there is no common canonical layout for the u-boot components across 
different boards. If you want to modify the partitioning with tools like 
<code>fdisk(8)</code>, you may keep in mind that <code>fdisk</code> always tries to 
create new partitions starting from sector 2048 by default.</p>

<p>U-boot tries to load the kernel image and additional files from the first partition 
of the designated boot device. Earlier u-boot versions supported only the vfat file 
system, which resulted in this typical partition layout:</p>

<table>
<thead>
<tr><th align="left">device</th><th align="left">label</th>
    <th align="left">filesystem&nbsp;&nbsp;&nbsp;</th><th align="left">mount point</th>
</tr>
</thead>
<tbody>
<tr><td><code>/dev/mmcblk0p1</code>&nbsp;&nbsp;</td><td>boot</td>
    <td>vfat</td><td><code>/media/boot</code></td>
</tr>
<tr><td><code>/dev/mmcblk0p2</code>&nbsp;&nbsp;</td><td>rootfs&nbsp;&nbsp;&nbsp;</td>
    <td>ext4</td><td><code>/</code></td>
</tr>
</tbody>
</table>

<p>Recent u-boot versions support reading files from ext4 file-systems, so there is no 
technical need to stick to the vfat boot partition.  Although many installer images keep 
on using it due to convenience reasons, e.g. editing <code>boot.ini</code> on Windows / 
OS X which don't support ext4 out of the box.</p>

<h4>u-boot commands</h4>

<p>The interactive u-boot shell offers a set of commands, depending on version and 
patch level. You can get a list of all supported commands by typing</p>

<pre>
help
</pre>

<p>and</p>

<pre>
help &lt;command>
</pre>

<p>For further information please refer to the very extensive <a href="http://www.denx.de/wiki/view/DULG/UBootCommandLineInterface">official documentation</a>.</p>

<h4>u-boot environment</h4>

<p>The u-boot environment stores a set of variables in the form 
<code>&lt;variable>=&lt;value></code>.  If a saved environment is available u-boot 
initializes the working environment with these values or falls back to the built-in 
default environment. Variables are referenced by <code>${variable}</code>.</p>

<pre>
printenv
</pre>

<p>prints out the whole set of variables, whereas</p>

<pre>
printenv variable
</pre>

<p>prints the value of a single variable</p>

<pre>
setenv variable value
</pre>

<p>sets a certain variable with the designated value</p>

<pre>
setenv variable
</pre>

<p>deletes a variable from the environment</p>

<pre>
env -a
</pre>

<p>resets the u-boot environment with the built-in defaults</p>

<pre>
saveenv
</pre>

<p>stores the current environment on the uSD or eMMC module.  You can also 
<a href="https://github.com/umiddelb/armhf/wiki/Get-more-out-of-%22Das-U-Boot%22#userland-access-to-the-u-boot-environment">read 
and modify the u-boot environment</a> when the system has started Linux.</p>

<h4>u-boot macros</h4>

<p>U-boot uses variables to store scripts, so</p>

<pre>
setenv macro '...;'
</pre>

<p>will define a variable called <code>macro</code> containing a list of commands, 
delimited by a semicolon (<code>;</code>). Macros may be invoked by typing the "run" 
command:</p>

<pre>
run macro
</pre>

<p>The most prominent macro is <code>bootcmd</code> which is run by default.  Macros 
return a value (the return value of the command executed at last) which can be evaluated 
by an <code>if ... ; then ... ; else ...;</code> clause. Additional information is 
'returned' by modifying specific variables, e.g. the <code>load</code> command uses 
the (global) variable <code>filesize</code> to return the number of bytes read from 
disk.</p>

<a name="BootSequence"></a>
<h4>Typical boot sequence</h4>

<hr>

<p>The macro <code>bootcmd</code> implements the boot sequence, executed in 
non-interactive mode. Prior to executing <code>bootcmd</code>, u-boot initializes the 
u-boot environment containing the configuration variables and macros. The typical 
steps inside <code>bootcmd</code> are:</p>

<h4>Load a custom environment from the boot partition</h4>

<p><code>bootcmd</code> looks for a text file called <code>uEnv.txt</code> on the boot 
partition, loads it and merges its contents with the existing u-boot environment by 
overriding values of existing variables.  This step is optional.</p>

<p><code>bootcmd</code> will then look for a file called <code>boot.scr</code> on the 
boot partition, load the file and execute its contents without returning back to 
<code>bootcmd</code>. <code>boot.scr</code> contains compiled u-boot commands in a 
binary format. This step is optional.</p>

<h4>Load the kernel image from the boot partition</h4>

<p><code>bootcmd</code> looks for the kernel image. The u-boot variable 
<code>kernel</code> contains the actual filename, usually <code>zImage</code>. You can 
boot an alternate kernel image by changing the variable <code>kernel</code>.</p>

<h4>Load the device tree binary from the boot partition</h4>

<p>The Linux kernel on ARM needs a low level device description (device tree) in binary 
format, either appended to the kernel image or as a separate file. Many platforms prefer 
loading the device tree binary as a separate file, which offers more flexibility, 
allowing distribution of a single installation image for different platforms, or 
tweaking of the device tree for different use cases. Some vendors let 
<code>bootcmd</code> decide on the actual device tree binary to load, depending on the 
board discovery performed by u-boot.</p>

<h4>Load the initial ramdisk archive from the boot partition</h4>

<p>The bootcmd macro will finally try to load the initial ramdisk archive from a file 
called <code>uInitrd</code>.  This archive is created and updated by using the 
update-initramfs utility, which is usually done when a new kernel image has been 
installed. This step is optional.</p>
<hr>

<h4>Userland access to the u-boot environment</h4>

<p>When the system has booted up you can still modify the u-boot environment. The Ubuntu 
package <code>u-boot-tools</code> contains fw_printenv(8) and fw_setenv(8) for accessing 
the stored u-boot environment. After installing the package with</p>

<pre>
sudo apt-get -y install u-boot-tools
</pre>

<p>you need to configure the storage device and address information in the file 
<code>/etc/fw_env.config</code>, e.g. for the ODROID-C1:</p>

<pre>
# &lt;device>   &lt;offset> &lt;length>
/dev/mmcblk0 0x80000   0x8000
</pre>

<p>and for the ODROID-XU3/XU4:</p>

<pre>
# &lt;device>   &lt;offset> &lt;length>
/dev/mmcblk0 0x99E00   0x4000
</pre>

<p>You can test the configuration with</p>

<pre>
sudo fw_printenv bootdelay
</pre>

<p>The u-boot environment stored on disk contains a CRC checksum. If offset/length 
doesn't match you will receive a warning, like:</p>

<pre>
Warning: Bad CRC, using default environment
</pre>

<p>To create an environment that can be modified with <code>u-boot-tools</code> halt 
the boot process during the early u-boot phase (you'll need to do this via an attached 
serial connection). At the u-boot prompt type 'saveenv'. u-boot will reply with a 
message of confirmation. Then <code>reset</code> to boot. When you next try 
<code>sudo fw_printenv</code> you should get a listing without the warning.</p>

<h4>Important</h4>

<p>Do not attempt to modify the u-boot environment if you are getting 
the CRC error. In all likelihood you will render your device unbootable.</p>

<h3>Typical use cases for the ODROID C1</h3>

<p>By default the ODROID-C1 is configured to boot via <a href="https://github.com/umiddelb/armhf/wiki/Get-more-out-of-%22Das-U-Boot%22#the-shortcut"><code>cfgload</code></a> 
with a very short boot delay. Increasing u-boot variable <code>bootdelay</code> gives 
you the chance to interrupt the automated boot process. You can use fw_setenv(8) to 
assign a new value to <code>bootdelay</code>:</p>

<pre>
sudo fw_printenv bootdelay
sudo fw_setenv bootdelay 3
</pre>

<p>prints the current value and sets the delay to 3 seconds.</p>

<h4>Boot an alternative kernel image</h4>

<p>If you compile your own kernel from source, you really want to test the new kernel 
before overwriting the current one or keep a known working kernel as backup. Booting a 
different than the default kernel can be done by defining an u-boot macro which refers 
to different files on the boot partition.</p>

<pre>
sudo setenv m_boot_ 'setenv bootargs "root=/dev/mmcblk0p2 rootwait rw console=ttyS0,115200n8 console=tty0 no_console_suspend \
vdaccfg=0xa000 logo=osd1,loaded,0x7900000,720p,full dmfc=3 cvbsmode=576cvbs hdmimode=1080p m_bpp=32 vout=hdmi disablehpd=true"; \
fatload mmc 0:1 0x21000000 _uImage;fatload mmc 0:1 0x22000000 uInitrd; fatload mmc 0:1 0x21800000 _meson8b_odroidc.dtb; \
fdt addr 21800000; fdt rm /mesonstream; fdt rm /vdec; fdt rm /ppmgr; fdt rm /mesonfb; bootm 0x21000000 0x22000000 0x21800000'
</pre>

<p>This defines the u-boot macro <code>m_boot_</code> which refers to the kernel image 
<code>_uImage</code> and the device binary <code>_meson8b_odroidc.dtb</code>. 
Unfortunately u-boot doesn't allow line feeds inside macros which makes them hard to 
read. If you insert a line feed after each <code>;</code> you will see the same command 
sequence as in <code>boot.ini</code>:</p>

<pre>
setenv bootargs "root=/dev/mmcblk0p2 rootwait rw console=ttyS0,115200n8 no_console_suspend vdaccfg=0xa000 \
logo=osd1,loaded,0x7900000,720p,full dmfc=3 cvbsmode=576cvbs hdmimode=1080p m_bpp=32 vout=hdmi disablehpd=true";
fatload mmc 0:1 0x21000000 _uImage;
fatload mmc 0:1 0x22000000 uInitrd;
fatload mmc 0:1 0x21800000 _meson8b_odroidc.dtb;
fdt addr 21800000;
fdt rm /mesonstream; 
fdt rm /vdec; 
fdt rm /ppmgr; 
fdt rm /mesonfb; 
bootm 0x21000000 0x22000000 0x21800000';
</pre>

<p>This is the effective command sequence during boot when configuring 
<code>boot.ini</code> to a headless configuration:</p>

<pre>
setenv vout_mode "hdmi"
setenv m_bpp "32"
setenv hpd "0"
setenv cec "0"
setenv vpu "0"
setenv hdmioutput "0"
</pre>

<p>Once you have defined the macro <code>m_boot_</code> and copied the kernel image and 
device tree binary to the boot partition with a leading '_' in the filename you can boot 
this kernel by interrupting u-boot and typing</p>

<pre>
run m_boot_
</pre>

<p>at the u-boot shell prompt.</p>

<h4>boot rootfs from a different partition, e.g from USB disk</h4>

<p>You might have noticed the kernel parameter <code>root=...</code> which u-boot passes 
to the Linux kernel. The kernel will try to mount the root filesystem (<code>/</code>) 
from there. The root filesystem can be adressed in different ways:</p>

<ul>
  <li>via device node: e.g. <code>root=/dev/sda1</code></li>
  <li>via UUID filesystem identifier: e.g. 
      <code>root=UUID=e139ce78-9841-40fe-8823-96a304a09859</code></li>
</ul>

<p>If you have only one USB storage device connected to your board you can safely 
address the root filesystem via device node. If you plan to dynamically connect/remove 
additional storage devices you're better off by addressing the root filesystem via the 
UUID identifier, otherwise the kernel might miss the root filesystem due to a 
'forgotten' USB stick during next boot.</p>

<p>You can read the available UUIDs via <code>blkid</code>:</p>

<pre>
$ sudo blkid
/dev/mmcblk0p1: SEC_TYPE="msdos" LABEL="boot" UUID="E26F-2230" TYPE="vfat"
/dev/mmcblk0p2: LABEL="rootfs" UUID="e139ce78-9841-40fe-8823-96a304a09859" TYPE="ext4"
/dev/mmcblk0p3: LABEL="rootfs2" UUID="e139ce78-9841-40fe-8823-96a304a09860" TYPE="ext4"
/dev/sda1: LABEL="rootfs" UUID="e54a458d-6a66-4ed2-9394-7b22d2943ec9" TYPE="ext4"
</pre>

<p>The UUID can be set while creating a filesystem with <code>mkfs</code>:</p>

<pre>
$ sudo mkfs.ext4 -O ^has_journal -b 4096 -L rootfs -U e54a458d-6a66-4ed2-9394-7b22d2943ec9 /dev/sda1 
</pre>

<p>If you omit the parameter <code>-U</code> the UUID is chosen ramdomly.</p>

<p>As in the previous section you can define an additional u-boot macro which will then 
pass an alternative root filesystem to the kernel:</p>

<pre>
sudo setenv m_boot_usb 'setenv bootargs "root=/dev/sda1 rootwait rw console=ttyS0,115200n8 console=tty0 no_console_suspend \
vdaccfg=0xa000 logo=osd1,loaded,0x7900000,720p,full dmfc=3 cvbsmode=576cvbs hdmimode=1080p m_bpp=32 vout=hdmi disablehpd=true"; \
fatload mmc 0:1 0x21000000 uImage;fatload mmc 0:1 0x22000000 uInitrd; fatload mmc 0:1 0x21800000 meson8b_odroidc.dtb; \
fdt addr 21800000; fdt rm /mesonstream; fdt rm /vdec; fdt rm /ppmgr; fdt rm /mesonfb; bootm 0x21000000 0x22000000 0x21800000'
</pre>

<p>Although it is not recommended, if you need to clone the contents of a mounted root 
filesystem you may perform a bind mount before copying:</p>

<pre>
$ sudo mount /dev/sda1 /media/usb
$ sudo mount -o bind / /mnt
$ cd /mnt
$ sudo find . | sudo cpio -dump /media/usb
$ cd
$ sudo umount /mnt
$ sudo umount /media/usb
</pre>

<p>Which then allows you to boot from USB by typing the following at the u-boot shell 
prompt:</p>

<pre>
run m_boot_usb
</pre>

<p>at the u-boot shell.</p>

<h3>References</h3>
<ul>
<li>[Porting Linux on ARM] (<a href="http://free-electrons.com/pub/conferences/2015/captronic/captronic-porting-linux-on-arm.pdf">http://free-electrons.com/pub/conferences/2015/captronic/captronic-porting-linux-on-arm.pdf</a>)</li>
</ul>

<h3>To be continued ...</h3>

</body></html>
