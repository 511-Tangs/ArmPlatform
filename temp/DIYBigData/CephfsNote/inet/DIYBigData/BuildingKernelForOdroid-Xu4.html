<!DOCTYPE html>
<html lang="en">
  <head><title>en:xu4_building_kernel    [Odroid Wiki]</title>
  </head>
<body>

<h4>Table Of Contents</h4>

<OL>
  <LI><a href="#CompilingLinuxForArm">Compiling Linux For Arm</a>
  <LI><a href="#MainlineKernelForXu4">Mainline Kernel For Xu4</a>
  <LI><a href="#GetMoreOutOfUboot">Get more out of "Das U Boot"</a>
  <LI><a href="./UbootReference">UbootReference</a>
</OL>

<a name="CompilingLinuxForArm"></a>
<h3>How To compile a custom Linux kernel for your ARM device 
<a href="https://github.com/umiddelb/armhf/wiki/How-To-compile-a-custom-Linux-kernel-for-your-ARM-device" 
target="_b">(Source Origin)</a></h3>

<div class="gh-header-meta">
   Uli Middelberg edited this page <relative-time title="Jan 13, 2017, 6:40 PM GMT+8" 
   datetime="2017-01-13T10:40:57Z">28 days ago</relative-time>

</div>

<p>This tutorial covers some aspects about compiling your own 
Linux kernel for your ARM device. Most Linux distributions for the 
PC/x86 platform maintain a Linux kernel which supports a broad range of 
hardware devices, so it has become very unlikely to compile your own 
kernel from source. For the ARM platform the Linux kernel is provided by
 the board or system on chip (SoC) manufacturer. In some cases these 
kernels include a minimal set of features and device drivers only.</p>

<p>Beside of this you may want to include a specific feature set which is provided as a 
patch set to the kernel sources only, like <a href="https://grsecurity.net/">enhanced 
security</a> or <a href="https://rt.wiki.kernel.org/index.php/Main_Page">real-time 
capabilities</a>.</p>

<p>Some use cases impose special requirements, e.g. you prefer to switch
 off loadable kernel modules support in security relevant environments 
and build a monolithic kernel instead. Or you have to cope with 
restricted resources and need to build a very tiny kernel image.</p>

<p>Recent ARM devices have become quite powerful, so I prefer to compile
 the kernel on the target device directly instead of cross compiling 
(which adds some extra level of complexity).</p>

<p>The people from the ODROID Magazine kindly published this article in their 
<a href="http://magazine.odroid.com/201601">2016-01 issue</a>.</p>

<h3>Kernel components</h3>

<p>The Linux kernel consists of the following components:</p>

<ul>
  <li>Kernel image 

  <ul>
    <li>32 bit platform: <code>&lt;boot-partition&gt;/zImage</code> or 
        <code>&lt;boot-partition&gt;/uImage</code>, depending on your u-boot's 
        capabilities and configuration</li>
    <li>64 bit platform: <code>&lt;boot-partition&gt;/Image</code></li>
  </ul></li>
  <li>Device tree binary, a low level device description, specific to your device 
      (<code>&lt;boot-partition&gt;/&lt;board&gt;.dtb</code>)</li>
  <li>Kernel modules (<code>/lib/modules/&lt;kernel-version&gt;/*</code>)</li>
  <li>Device firmware (<code>/lib/firmware/*</code>)</li>
  <li>Kernel C header files (<code>/usr/include/linux</code>)</li>
</ul>

<p> Theses components are build out of the kernel sources with the help of the 
<code>make</code> utility. Usually the kernel image and the device tree binary are 
loaded from a small vfat boot partition (mounted as <code>/boot</code> or 
<code>/media/boot</code>), whereas the rest resides in the root file system.</p>

<h3>Prepare your build environment</h3>

<p>Beside of <code>make</code>, several other utilities are needed to compile the 
Linux kernel, e.g. for Ubuntu you need to install the following packages</p>

<pre>
sudo apt-get -y install bc curl gcc git libncurses5-dev lzop make u-boot-tools
</pre>


<h4>Make gcc-5 your default compiler</h4>

<p>Most Linux distributions are updating their default compiler to gcc 
version 5 as time of this writing. If your distribution still uses gcc 
version 4.8 as default you should consider to gcc version 5, e.g. for 
Ubuntu 14.04:</p>

<pre>
apt-get -y install python-software-properties;
add-apt-repository -y ppa:ubuntu-toolchain-r/test;
apt-get update
apt-get -y install gcc-5 g++-5
update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50
update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 50
</pre>


<p>The command <code>update-alternatives</code> helps you to define the 
default command to be executed if different versions of the same command
 are installed at the same time. </p>

<p>You can check the gcc version with</p>

<pre>
gcc --version
</pre>


<h4>Become familiar with u-boot</h4>

<p>Compiling a custom kernel always comes with the risk that your new 
kernel won't boot for whatever reason. Some knowledge about the ARM boot
 loader <code>u-boot</code> helps you to boot a well known kernel image 
and to get your ARM device up again. I recommend to define an u-boot 
macro which will load and boot a test kernel before overwriting the 
existing default kernel. You can find more information about u-boot 
<a href="#GetMoreOutOfUboot" target="_b">here</a>.</p>

<h3>Download kernel sources</h3>

<p>The site <a href="http://www.kernel.org/">www.kernel.org</a> offers the mainline 
Linux kernel sources for download, e.g.:</p>

<pre>
curl -sSL https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.7.5.tar.xz | unxz | tar -xvf -
</pre>


<p>You can get the most recent releases there, but only a few ARM 
devices are able to boot a mainline kernel out of the box, and even if 
they have successfully started Linux, it is very likely that some 
devices still lack of support, e.g. graphics acceleration. </p>

<p>To get a kernel with extensive support for your ARM board, you need 
to fetch the kernel sources provided by the board vendor. In most cases 
these sources contain additional patches for a kernel version with long 
term support. Today many vendors use <a href="https://github.com/">github</a> to 
provide and manage their specific kernel sources, which makes it very easy to add 
back own contributions.  Usually the vendors organize the kernel sources for particular 
boards in designated github branches:</p>

<table>
<thead>
<tr>
<th align="right">Board</th>
<th align="right">Linux 3.8</th>
<th align="right">Linux 3.10</th>
<th align="right">Linux 3.14</th>
<th align="right">Linux 4.2</th>
<th align="right">Linux 4.8</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">Utilite</td>
<td align="right">-</td>
<td align="right"><a href="https://github.com/utilite-computer/linux-kernel">utilite/devel</a></td>
<td align="right"><a href="https://github.com/umiddelb/linux-fslc">3.14-1.0.x-mx6-sr</a></td>
<td align="right">-</td>
<td align="right"><a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.8.tar.xz">mainline</a></td>
</tr>
<tr>
<td align="right">CuBox-i</td>
<td align="right">-</td>
<td align="right">&nbsp;&nbsp;<a href="https://github.com/SolidRun/linux-imx6-3.14" 
                  target="_b">linux-linaro-lsk-3.10.42-mx6</a></td>
<td align="right">&nbsp;&nbsp;<a href="https://github.com/SolidRun/linux-fslc.git" 
                  target="_b">3.14-1.0.x-mx6-sr</a></td>
<td align="right"><a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.2.8.tar.xz">mainline</a></td>
<td align="right"><a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.8.tar.xz">mainline</a></td>
</tr>
<tr>
<td align="right">RaspberryPi 1/2</td>
<td align="right"><a href="https://github.com/raspberrypi/linux">rpi-3.8.y</a></td>
<td align="right"><a href="https://github.com/raspberrypi/linux">rpi-3.10.y</a></td>
<td align="right"><a href="https://github.com/raspberrypi/linux">rpi-3.14.y</a></td>
<td align="right"><a href="https://github.com/raspberrypi/linux">rpi-4.2.y</a></td>
<td align="right"><a href="https://github.com/raspberrypi/linux">rpi-4.8.y</a></td>
</tr>
<tr>
<td align="right">ODROID C1(+)</td>
<td align="right">-</td>
<td align="right"><a href="https://github.com/hardkernel/linux">odroidc-3.10.y</a></td>
<td align="right">-</td>
<td align="right">-</td>
<td align="right"><a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.8.tar.xz">(mainline)</a></td>
</tr>
<tr>
<td align="right">ODROID C2</td>
<td align="right">-</td>
<td align="right">-</td>
<td align="right"><a href="https://github.com/hardkernel/linux">odroidc2-3.14.y</a></td>
<td align="right">-</td>
<td align="right"><a href="https://github.com/xdarklight/linux/tree/meson-gxbb-integration-4.8-20160923">(mainline)</a></td>
</tr>
<tr>
<td align="right">ODROID X2</td>
<td align="right"><a href="https://github.com/hardkernel/linux">odroid-3.8.y</a></td>
<td align="right">-</td>
<td align="right">-</td>
<td align="right">-</td>
<td align="right">&nbsp;&nbsp;<a href="https://github.com/tobiasjakobi/linux-odroid-public/tree/odroid-4.8.y" 
                  target="_b">odroid-4.8.y</a></td>
</tr>
<tr>
<td align="right">ODROID U3</td>
<td align="right">&nbsp;&nbsp;<a href="https://github.com/hardkernel/linux" 
                  target="_b">odroid-3.8.y</a></td>
<td align="right">-</td>
<td align="right">-</td>
<td align="right">-</td>
<td align="right">-</td>
</tr>
<tr>
<td align="right">ODROID XU3</td>
<td align="right">-</td>
<td align="right">&nbsp;&nbsp;<a href="https://github.com/hardkernel/linux" 
                  target="_b">odroidxu3-3.10.y</a></td>
<td align="right">-</td>
<td align="right">-</td>
<td align="right">-</td>
</tr>
<tr>
<td align="right">ODROID XU4</td>
<td align="right">-</td>
<td align="right"><a href="https://github.com/hardkernel/linux">odroidxu3-3.10.y</a></td>
<td align="right">-</td>
<td align="right">&nbsp;&nbsp;<a href="https://github.com/tobetter/linux" 
                  target="_b">odroidxu4-v4.2</a></td>
<td align="right"><a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.8.tar.xz">mainline</a></td>
</tr>
<tr>
<td align="right">PINE64</td>
<td align="right">-</td>
<td align="right"><a href="https://github.com/longsleep/linux-pine64">pine64-hacks-1.2</a></td>
<td align="right">-</td>
<td align="right">-</td>
<td align="right"><a href="https://github.com/apritzel/linux/tree/a64-v5">(mainline)</a></td>
</tr>
</tbody>
</table>

<p>The <code>git clone</code> command creates a local copy of the origin repository 
by  </p>

<pre>
git clone --depth 1 --single-branch -b &lt;branch&gt; &lt;URL to the repository&gt;
</pre>


<p>This local copy contains only the branch specified by <code>-b</code> and no 
information about prior commits (--depth 1) which will reduce the download size to a 
certain extend. For example </p>

<pre>
git clone --depth 1 --single-branch -b odroidc-3.10.y https://github.com/hardkernel/linux
</pre>


<p>downloads the kernel source code for the ODROID C1 into the directory 
<code>./linux</code>.</p>

<h3>Build your custom kernel</h3>

<p>It's time to start building your own kernel now. After downloading and extracting 
the kernel sources you start with creating the configuration file called 
<code>.config</code>. This text file contains the relevant parameters for your kernel, 
one line per kernel option.</p>

<pre>
cd linux
make &lt;default_config&gt;
less .config
</pre>


<p>You can find the default configuration available for your ARM device in the directory 
<code>./arch/arm/configs/</code>. These are for the boards mentioned above:</p>

<table>
<thead>
<tr>
<th align="right">Device</th>
<th align="right">default configuration</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">Utilite</td>
<td align="right"><code>cm_fx6_defconfig</code></td>
</tr>
<tr>
<td align="right">CuBox-i</td>
<td align="right"><code>imx_v7_cbi_hb_defconfig</code></td>
</tr>
<tr>
<td align="right">RaspberryPi 1</td>
<td align="right"><code>bcmrpi_defconfig</code></td>
</tr>
<tr>
<td align="right">RaspberryPi 2</td>
<td align="right"><code>bcm2709_defconfig</code></td>
</tr>
<tr>
<td align="right">ODROID C1(+)</td>
<td align="right"><code>odroidc_defconfig</code></td>
</tr>
<tr>
<td align="right">ODROID C2</td>
<td align="right"><code>odroidc2_defconfig</code></td>
</tr>
<tr>
<td align="right">ODROID X2</td>
<td align="right"><code>exynos_defconfig</code></td>
</tr>
<tr>
<td align="right">ODROID U3</td>
<td align="right"><code>odroidu_defconfig</code></td>
</tr>
<tr>
<td align="right">ODROID XU3</td>
<td align="right"><code>odroidxu3_defconfig</code></td>
</tr>
<tr>
<td align="right">ODROID XU4</td>
<td align="right"><code>odroidxu4_defconfig</code></td>
</tr>
<tr>
<td align="right">PINE64</td>
<td align="right">&nbsp;&nbsp;&nbsp;<code>sun50iw1p1smp_linux_defconfig</code></td>
</tr>
</tbody>
</table>

<p>Once the kernel configuration <code>.config</code> has been created you can modify 
it either with a text editor of your choice or by starting</p>

<pre>
make menuconfig
</pre>


<p><img target="_b" 
src="https://raw.githubusercontent.com/umiddelb/armhf/master/img/make-menuconfig.png" 
alt="sreenshot of make menuconfig"></p>

<p>and changing the kernel configuration interactively.</p>

<p>If enabled as a configuration option you can read the current kernel configuration 
of a running kernel by: </p>

<pre>
cat /proc/config.gz | gunzip | less
</pre>


<p>When you are done with the kernel configuration you may create a new default 
configuration by starting:</p>

<pre>
make savedefconfig
</pre>


<p>This command creates a file called <code>defconfig</code> out of <code>.config</code> 
which contains only the changes with respect to the global kernel configuration defaults 
and reduces the file size to 15%-20% of the original <code>.config</code>. </p>

<p>The next step is to build the kernel image (<code>Image</code>, <code>uImage</code> 
or <code>zImage</code>), the device tree binary and the kernel modules. This is the 
most time consuming task and even with parallel execution (<code>make -j 4</code>) 
it takes about one hour the compile the C1 Linux on the C1 itself (and 20 minutes on 
the XU4):</p>

<pre>
make -j 4 [u|z]Image dtbs modules
</pre>


<h3>Install your custom kernel</h3>

<p>As mentioned earlier, you might want to test your new kernel before replacing your 
existing one. This step requires some knowledge about u-boot and the particular u-boot 
configuration for your board. You need to define an u-boot macro which boots your custom 
kernel instead of the system default. </p>

<p>When you're done with testing, you can install the new kernel as the system 
default.</p>

<pre>
sudo cp ./arch/arm/boot/*(u)*(z)Image ./arch/arm/boot/dts/*.dtb &lt;boot-partition&gt;
sudo make modules_install
sudo make firmware_install
sudo make headers_install INSTALL_HDR_PATH=/usr
</pre>


<p>The kernel image and the device tree binary are installed in the boot partition 
whereas the kernel modules, the device firmware and the C header files are copied to 
the root file system. If you are running different Linux installations on different 
partitions of your eMMC or SD storage device with the same kernel image you need to 
install the kernel modules (e.g. by <code>sudo make modules_install 
INSTALL_MOD_PATH=...</code>), the device firmware (<code>sudo make firmware_install 
INSTALL_FW_PATH=...</code>) and the C header files on each of this partitions. You can 
get a list of all make targets and parameters by typing <code>make help</code>.  </p>

<h3>Update you initramfs/initrd image</h3>

<p>Some configurations require a ramdisk image 
(<code>&lt;boot-partition>/uInitrd</code>) to be loaded during startup before entering 
the 'real' root file system. This ramdisk image contains some startup scripts and the 
kernel modules for a particular kernel. The command <code>update-initramfs</code> 
creates or updates this image. Please make sure that the kernel modules don't contain 
debug information (remove <code>CONFIG_DEBUG_INFO=y</code> from your kernel 
configuration), otherwise the ramdisk image size will grow significantly and might break 
space limitations imposed by the boot loader. </p>

<p>Instead of building the kernel modules again you can remove the debug information 
by executing:</p>

<pre>
<code>cd /lib/modules/&lt;kernel version&gt;
sudo find . -type f -name '*.ko' | sudo xargs -n 1 objcopy --strip-unneeded       
</code>
</pre>

<p>The image created by <code>update-initramfs</code> has to be translated into an 
u-boot loadable image via <code>mkimage</code> and to be copied to the boot partition, 
see the examples section for further details. </p>

<h3>How-To contribute</h3>

<p>GitHub makes it very easy to manage you own fork of the kernel sources and to 
suggest changes to the upstream repository. This <a target="_b" 
href="https://guides.github.com/activities/forking/">guide here</a> is a good 
starting point for inexperienced GitHub Users.   </p>

<h3>Examples</h3>

<P>If you are looking for ODROID-XU4 Mainline (Linux 4.9) and skipping the rest, goto 
<a href="#ODROID-XU4Mainline" target="_b">Here</a>.

<h4><a href="http://odroid.com/dokuwiki/doku.php?id=en:c1_ubuntu_release_note_v1.2" 
target="_b">ODROID-C1(+)</a></h4>

<pre>
$ git clone --depth 1 --single-branch -b odroidc-3.10.y https://github.com/hardkernel/linux
$ cd linux
$ make odroidc_defconfig
$ make -j 4 uImage dtbs modules
$ sudo cp arch/arm/boot/uImage arch/arm/boot/dts/*.dtb /media/boot
$ sudo make modules_install
$ sudo make firmware_install
$ sudo make headers_install INSTALL_HDR_PATH=/usr
$ kver=`make kernelrelease`
$ sudo cp .config /boot/config-${kver}
$ cd /boot
$ sudo update-initramfs -c -k ${kver}
$ sudo mkimage -A arm -O linux -T ramdisk -a 0x0 -e 0x0 -n initrd.img-${kver} -d initrd.img-${kver} uInitrd-${kver}
$ sudo cp uInitrd-${kver} /media/boot/uInitrd
</pre>


<h4><a href="http://linux-meson.com/doku.php" 
target="_b">ODROID-C1 mainline (experimental!)</a></h4>

<pre>
$ curl -sSL https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.8.tar.xz | unxz | tar -xvf -
$ cd linux
$ make multi_v7_defconfig
$ make -j 4 LOADADDR=0x00208000 uImage dtbs modules
$ sudo cp arch/arm/boot/uImage arch/arm/boot/dts/*.dtb /media/boot
$ sudo make modules_install
$ sudo make firmware_install
</pre>


<h4><a href="http://odroid.com/dokuwiki/doku.php?id=en:c2_ubuntu_release_note_v1.0" 
target="_b">ODROID-C2</a></h4>

<pre>
$ git clone --depth 1 --single-branch -b odroidc2-3.14.y https://github.com/hardkernel/linux
$ cd linux
$ make odroidc2_defconfig
$ make -j 4 Image dtbs modules
$ sudo cp arch/arm64/boot/Image arch/arm64/boot/dts/meson64_odroidc2.dtb /media/boot
$ sudo make modules_install
$ sudo make firmware_install
$ sudo make headers_install INSTALL_HDR_PATH=/usr
$ kver=`make kernelrelease`
$ sudo cp .config /boot/config-${kver}
$ cd /boot
$ sudo update-initramfs -c -k ${kver}
$ sudo mkimage -A arm64 -O linux -T ramdisk -a 0x0 -e 0x0 -n initrd.img-${kver} -d initrd.img-${kver} uInitrd-${kver}
$ sudo cp uInitrd-${kver} /media/boot/uInitrd
</pre>


<h4><a href="http://linux-meson.com/doku.php" target="_b">ODROID-C2 mainline 
(experimental!)</a></h4>

<pre>
git clone --depth 1 --single-branch -b c2 https://github.com/ioft/linux
img="Image"
arch="arm64"
dtbs="dtbs"
make odroidc2_defconfig
make clean
make -j 4 ${img} modules ${dtbs}
kver=`make kernelrelease`
dest="/boot/kernel.d/linux-${kver}"
sudo rm -rf ${dest}
sudo mkdir -p ${dest}
sudo rm -rf /boot/kernel.d/test
sudo ln -s ${dest} /boot/kernel.d/test
sudo cp System.map arch/${arch}/boot/${img} arch/${arch}/boot/dts/amlogic/*.dtb ${dest}
sudo mkimage -A ${arch} -O linux -T kernel -C none -a 0x1080000 -e 0x1080000 -n ${kver} -d arch/${arch}/boot/${img} ${dest}/uImage
sudo cp .config ${dest}/config-${kver}
sudo make modules_install
sudo make firmware_install
sudo make headers_install INSTALL_HDR_PATH=/usr
cd /boot
sudo rm -f config-${kver}
sudo rm -f initrd.img-${kver}
sudo ln -s ${dest}/config-${kver} .
sudo update-initramfs -c -k ${kver}
sudo mkimage -A ${arch} -O linux -T ramdisk -a 0x0 -e 0x0 -n initrd-${kver}.img -d initrd.img-${kver} uInitrd-${kver}
sudo mv initrd.img-${kver} ${dest}
sudo mv uInitrd-${kver} ${dest}/uInitrd
sudo rm config-${kver}
</pre>


<h4><a href="http://linux-exynos.org/wiki/Hardkernel_ODROID-X2" 
target="_b">ODROID-X2</a></h4>

<p>See <strong>kernel setup and build</strong> in the Wiki for build instructions of both kernel and u-boot.</p>

<h4><a href="http://odroid.com/dokuwiki/doku.php?id=en:u3_building_kernel" 
target="_b">ODROID-U3</a></h4>

<pre>
$ git clone --depth 1 --single-branch -b odroid-3.8.y https://github.com/hardkernel/linux
$ cd linux 
$ make odroidu_defconfig
$ make -j 4 zImage modules
$ sudo cp arch/arm/boot/zImage /media/boot
$ sudo make modules_install
$ sudo make firmware_install
$ sudo make headers_install INSTALL_HDR_PATH=/usr
$ kver=`make kernelrelease`
$ sudo cp .config /boot/config-${kver}
$ cd /boot
$ sudo update-initramfs -c -k ${kver}
$ sudo mkimage -A arm -O linux -T ramdisk -a 0x0 -e 0x0 -n initrd.img-${kver} -d initrd.img-${kver} uInitrd-${kver}
$ sudo cp uInitrd-${kver} /media/boot/uInitrd
</pre>


<h4><a href="http://odroid.com/dokuwiki/doku.php?id=en:xu3_building_kernel" 
target="_b">ODROID-XU3</a></h4>

<pre>
$ git clone --depth 1 --single-branch -b odroidxu3-3.10.y https://github.com/hardkernel/linux
$ cd linux 
$ make odroidxu3_defconfig
$ make -j 8 zImage dtbs modules
$ sudo cp arch/arm/boot/zImage arch/arm/boot/dts/*.dtb /media/boot
$ sudo make modules_install
$ sudo make firmware_install
$ sudo make headers_install INSTALL_HDR_PATH=/usr
$ kver=`make kernelrelease`
$ sudo cp .config /boot/config-${kver}
$ cd /boot
$ sudo update-initramfs -c -k ${kver}
$ sudo mkimage -A arm -O linux -T ramdisk -a 0x0 -e 0x0 -n initrd.img-${kver} -d initrd.img-${kver} uInitrd-${kver}
$ sudo cp uInitrd-${kver} /media/boot/uInitrd
</pre>


<h4><a href="http://odroid.com/dokuwiki/doku.php?id=en:xu4_building_kernel" 
target="_b">ODROID-XU4</a></h4>

<pre>
$ git clone --depth 1 --single-branch -b odroidxu4-v4.2 https://github.com/tobetter/linux
$ cd linux 
$ make odroidxu4_defconfig
$ make -j 8 zImage dtbs modules
$ sudo cp arch/arm/boot/zImage arch/arm/boot/dts/*.dtb /media/boot
$ sudo make modules_install
$ sudo make firmware_install
$ sudo make headers_install INSTALL_HDR_PATH=/usr
$ kver=`make kernelrelease`
$ sudo cp .config /boot/config-${kver}
$ cd /boot
$ sudo update-initramfs -c -k ${kver}
$ sudo mkimage -A arm -O linux -T ramdisk -a 0x0 -e 0x0 -n initrd.img-${kver} -d initrd.img-${kver} uInitrd-${kver}
$ sudo cp uInitrd-${kver} /media/boot/uInitrd
</pre>

<a name="ODROID-XU4Mainline"></a>
<h4><a href="https://github.com/ioft/linux/" target="_b">ODROID-XU4 mainline</a></h4>

<P><b>Note: (02/13/2017)</b> After make odroidxu4_defconfig, use "$ make menuconfig" 
command, to turn on the "kvm virtualization" and "ceph filesystem" support options.  By 
default, these options are "OFF", I believe.  <b>(02/25/2017)</b> Now, we should try on 
own <a target="_b" href="./My-Odroid-Xu4-defconfig">My-Odroid-Xu4-defconfig</a>, 
see <a href="#MainlineKernelBuild" target="_b">Build the Mainline Kernel</a>

<pre>
$ git clone --depth 1 --single-branch -b master https://github.com/ioft/linux/
$ cd linux  
$ make odroidxu4_defconfig
$ make -j 8 zImage dtbs modules
$ sudo cp arch/arm/boot/zImage arch/arm/boot/dts/*.dtb /media/boot
$ sudo cp .config /media/boot/config
$ sudo make modules_install
$ sudo make firmware_install
$ sudo make headers_install INSTALL_HDR_PATH=/usr
$ kver=`make kernelrelease`
$ sudo cp .config /boot/config-${kver}
$ cd /boot
$ sudo update-initramfs -c -k ${kver}
$ sudo mkimage -A arm -O linux -T ramdisk -a 0x0 -e 0x0 -n initrd.img-${kver} -d initrd.img-${kver} uInitrd-${kver}
$ sudo cp uInitrd-${kver} /media/boot/uInitrd
</pre>


<h4><a href="https://www.pine64.com/product" target="_b">PINE64 3.10 BSP kernel</a></h4>

<pre>
<code>$ git clone --depth 1 --single-branch -b pine64-hacks-1.2 https://github.com/longsleep/linux-pine64
$ curl -sSL https://github.com/longsleep/build-pine64-image/raw/master/blobs/pine64.dts &gt; \
        linux-pine64/arch/arm64/boot/dts/sun50i-a64-pine64-plus.dts
$ cd linux-pine64
$ make sun50iw1p1smp_linux_defconfig
$ make -j 4 Image sun50i-a64-pine64-plus.dtb modules
$ sudo cp arch/arm64/boot/dts/sun50i-a64-pine64-plus.dtb arch/arm64/boot/Image /boot/pine64
$ sudo make modules_install
$ sudo make firmware_install
$ sudo make headers_install INSTALL_HDR_PATH=/usr
$ kver=`make kernelrelease`
$ sudo cp .config /boot/config-${kver}
$ cd /boot
$ sudo update-initramfs -c -k ${kver}
$ sudo mv initrd.img-${kver} initrd.img
$ sudo mv config-${kver} /boot/pine64
</code>
</pre>

<h4><a href="https://www.pine64.com/product" target="_b">PINE64 mainline kernel</a></h4>

<pre>
<code>$ git clone --depth 1 --single-branch -b a64-v6-wip https://github.com/apritzel/linux
$ cd linux
$ make defconfig
$ make -j 4 Image modules dtbs
$ sudo cp arch/arm64/boot/dts/*.dtb arch/arm64/boot/Image /boot/pine64
$ sudo make modules_install
$ sudo make firmware_install
$ sudo make headers_install INSTALL_HDR_PATH=/usr
$ kver=`make kernelrelease`
$ sudo cp .config /boot/config-${kver}
$ cd /boot
$ sudo update-initramfs -c -k ${kver}
$ sudo mv initrd.img-${kver} initrd.img
$ sudo mv config-${kver} /boot/pine64
</code>
</pre>

<h3>Building a test kernel on ODROID boards</h3>

<ul>
  <li>Copy to contents of <code>/media/boot</code> to a new directory on your boot 
      partition e.g. <code>/media/boot/backup</code>.<br></li>
  <li>If your test kernel has the same version as your productive one, you should define 
      a naming extension (e.g. <code>CONFIG_LOCALVERSION="-dev"</code>) in the kernel 
      configuration <code>.config</code> in order to prevent the current kernel modules 
      to be overwritten.</li>
  <li>Copy the kernel image and the device tree binary to <code>/media/boot/test</code> 
      instead of <code>/media/boot</code></li>
  <li>If you don't have serial console access, you may choose to tweak the file 
      <code>/media/boot/boot.ini</code>. You can modify the path for loading the kernel 
      and the device tree binary, e.g. for the ODROID C1:</li>
</ul>

<pre>
<code>setenv prefix '/test/'
...
fatload mmc 0:1 0x21000000 ${prefix}uImage
fatload mmc 0:1 0x22000000 uInitrd
fatload mmc 0:1 0x21800000 ${prefix}meson8b_odroidc.dtb
...
</code>
</pre>

<p>If you want to switch back to your backup kernel image, you change the u-boot 
variable <code>prefix</code> to <code>/backup/</code>.</p>

<ul>
  <li>If you have access to u-boot via serial console, you may define an u-boot macro, 
      which loads the kernel image and the device tree binary from 
      <code>/media/boot/test</code>, see <a target="_b" 
      href="https://github.com/umiddelb/armhf/wiki/Get-more-out-of-%22Das-U-Boot%22#boot-an-alternative-kernel-image">here</a> 
      for more details.</li>
</ul>

<p>Please don't forget to run <code>make clean</code> before building a kernel again.</p>
<hr>


<a name="MainlineKernelForXu4"></a>
<article id="post-3312">					
<img src="https://blogs.s-osg.org/wp-content/uploads/2016/06/XU4packagem.jpg" alt="">	

<p id="single-meta">June 9, 2016 -  Shuah Khan</p>


<h3 id="single-heading">How to Install Ubuntu and Run a Mainline Kernel on an 
ODROID-XU4 
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/" 
target="_b">(Source Origin)</a></h3>			

<p>I recently installed Ubuntu 15.10 on Odroid-XU4 and set out to run the upstream 
kernel on it. After several trials and errors and being forced to reference various 
forums, I now have Odroid running the Linux 4.6 Kernel. In this article, I will 
share how to quickly get from unboxing to running the latest kernel with a short detour 
to upgrade to the Ubuntu 16.04 release.</p>


<p>Without further ado, let's get started. First of all, download the Ubuntu 15.10 
image. You can find the release notes and self installing image here:</p>


<ul>
  <li><a href="http://odroid.com/dokuwiki/doku.php?id=en:xu3_ubuntu_release_note_20160114">Release notes for Ubuntu 15.10 (v1.0)</a></li>
  <li><a href="http://odroid.in/ubuntu-15.10/ubuntu-15.10-mate-odroid-xu3-20160114.img.xz">ubuntu-15.10-mate-odroid-xu3-20160114.img.xz</a></li>
</ul>


<h4>Prepare the microSD Card</h4>


<p>Once you've downloaded the image from the 2nd link above, follow the following steps 
to create a bootable microSD card with the image; I used a 32 GB Samsung microSD card. 
Insert the microSD card in its SD card adapter case in the SD card slot on your host PC 
or laptop. Please note that SD card will likely be auto-mounted. Check for the device 
files and unmount all partitions as needed. If this a brand new SD card you don't have 
to worry about this step.</p>


<p>Uncompress the image:</p>


<PRE>
$ tar -unxz ubuntu-15.10-mate-odroid-xu3-20160114.img.xz
</PRE>


<p>Prepare microSD - Insert SD Card and look for auto-mounted partitions:</p>


<PRE>
$ df -h
...
/dev/mmcblk0p2 30G 8.3G 21G 29% /media/shuah/rootfs
/dev/mmcblk0p1 128M 20M 108M 16% /media/shuah/boot
</PRE>


<p>Check device files</p>


<PRE>
$ ls /dev/mmcblk*
/dev/mmcblk0 
/dev/mmcblk0p1 
/dev/mmcblk0p2
</PRE>


<p>First unmount the auto-mounted partitions:</p>


<PRE>
$ umount /dev/mmcblk0p1
$ umount /dev/mmcblk0p2
</PRE>


<p>Erase microSD card (the following writes ~8192 4M blocks to erase the entire 
disk):</p>

<PRE>
$ dd if=/dev/zero of=/dev/mmcblk0 count=8192 bs=4M
</PRE>


<p>Copy self installing image to microSD Card:</p>


<PRE>
$ dd if=ubuntu-15.10-mate-odroid-xu3-20160114.img of=/dev/mmcblk0
</PRE>


<h4>Get Your ODROID-XU4 Up and Running</h4>


<p> Now you are ready to use the microSD to boot the self install image. Insert the 
microSD card in the microSD slot in the Odroid.  Make sure Boot Select Switch is in 
the correct position to enable microSD as the boot device.</p>


<p> Hopefully you have a the USB-UART Module Kit for the Odroid. If you don't please 
get one! It is a must for kernel development. Please refer to the ODroid wiki for <a 
href="http://odroid.com/dokuwiki/doku.php?id=en:usb_uart_kit" target="_b">instructions 
on how to connect to Odroid serial console port</a>. An alternative option is to simply 
connect the device's HDMI to a monitor and hook up a USB keyboard and mouse.</p>


<p> It is time to give your Odroid boot a try. Power up the Odroid and you should 
see the ALIVE/Blue Starts LED start out solid while in u-boot and quickly go into 
flashing mode when kernel starts running. At this point, sit back and relax, the 
Ubuntu self-install image will boot and complete the instalation. If all goes well, 
the ALIVE/Blue Status LED continues to flash and you will see boot messages on the 
console and Odroid login appear on the monitor. During the install, a boot partition 
will be made with a rootfs being placed on the remaining space.  There is ample room 
in the boot partition for a few kernel images. You will notice that the boot partition 
is auto-mounted at /media/boot.</p>


<p> The Ubuntu 15.10 image is complete with all the development tools except for the 
liveboot package. We will talk about this later. Login is odroid and password is odroid. 
Start the Software Updater and pull in any updates. You will have the opportunity to 
upgrade to 16.04. If you do upgrade, please keep in mind that you will have to bring in 
new video driver to get GUI working on 16.04. Please refer to <a target="_b" 
href="http://forum.odroid.com/viewtopic.php?f=95&amp;t=20765">GUI after upgrade to 
Ubuntu 16.04 on XU4</a>. The following is a distilled list of commands that worked 
for me.</p>


<PRE>
$ sudo apt-add-repository ppa:canonical-x/x-staging
$ sudo apt-get update
$ sudo apt-get purge xserver-xorg-video-armsoc*
$ sudo apt-get install xserver-xorg-video-armsoc-exynos
</PRE>


<p> Once the above step is done, power down completely (don't choose restart). Please 
note that when the HDMI is connected, the HDMI return power supplies enough power for 
Odroid's PWR Status LED to stay on. Please disconnect HDMI to ensure the Ordroid is 
completely powered down before powering it back up. Please don't insert and/or remove 
microSD while the PWR Status LED is on. Once the PWR Status is off, it safe to power 
on the Odroid. At this point with the GUI should be working. <em><strong>Please 
note:</strong></em> If you have problems with fonts not rendering properly, click 
"System" in the top left corner of the screen and go to Preferences >> Appearance; 
then, select the Fonts tab and choose "Subpixel smoothing" in the Rendering section.</p>


<a name="MainlineKernelBuild"></a>
<h4>Build the Mainline Kernel</h4>


<p> Now we are ready to build, install, and boot mainline kernels. The latest linux-next 
is a good repo to use. I will describe what I needed to do build, install and run kernel 
based on this repo.  I would recommend doing a native build on Odroid as it is fast 
enough and worked well for me. I built kernels with and without CONFIG_EXYNOS_IOMMU 
enabled. Contiguous Memory Allocation (CMA) is the default mode for memory allocation. 
When IOMMU is enabled, non-contiguous memory is allocated using Exynos IOMMU hardware. 
Both flavors worked for me.</p>


<p>Clone the linux-next git repo (do this on the XU4 if you want to do a native kernel 
build on the Odroid): <a target="_b" 
href="http://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/">Visit 
Linux Next</a></p>


<PRE>
$ cd /tmp 
$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git linux_odroid
Cloning into 'linux_odroid'...
remote: Counting objects: 5340565, done.
remote: Compressing objects: 100% (178697/178697), done.
remote: Total 5340565 (delta 145149), reused 0 (delta 0)
Receiving objects: 100% (5340565/5340565), 973.39 MiB | 966.00 KiB/s, done.
Resolving deltas: 100% (4474606/4474606), done.
Checking out files: 100% (57764/57764), done.
$ cd linux_odroid
$ head -5 Makefile
VERSION = 4
PATCHLEVEL = 10
SUBLEVEL = 0
EXTRAVERSION = 
NAME = Fearless Coyote
</PRE>


<p>Move into the new <em>linux_odroid</em> directory,  generate the config, prepare 
modules, and build: (Please note: If you like to enable IOMMU, apply the following 
patch or edit arch/arm/configs/exynos_defconfig to add the lines 
<code>CONFIG_EXYNOS_IOMMU=y</code>, then run make exynos_defconfig</p>


<PRE>
diff --git a/arch/arm/configs/exynos_defconfig b/arch/arm/configs/exynos_defconfig
index daf9762..76127dc 100644
--- a/arch/arm/configs/exynos_defconfig
+++ b/arch/arm/configs/exynos_defconfig
@@ -218,6 +218,7 @@ CONFIG_CROS_EC_CHARDEV=y
 CONFIG_COMMON_CLK_MAX77686=y
 CONFIG_COMMON_CLK_MAX77802=y
 CONFIG_COMMON_CLK_S2MPS11=y
+CONFIG_EXYNOS_IOMMU=y
 CONFIG_EXTCON=y
 CONFIG_EXTCON_MAX14577=y
 CONFIG_EXTCON_MAX77693=y
</PRE>

<hr>
<P><b>Note: (02/22/2017)</b> It seems kvm setting has no effect on the generated .config 
   file. We must enable LPAE (Large Physical Address Extension) in "System Type" submenu,
   and then we can type '/' to search for kvm during menuconfig and see its dependencies.

<P> <a href="http://pastebin.com/7YnakKmP" target="_b">Odroid xu4 4.8.5 kernel merged 
config</a>  We can work on this file by turning on the following settings to get our 
own <a href="My-Odroid-Xu4-defconfig" target="_b">My-Odroid-Xu4-defconfig</a> 

<OL>
  <LI>"CONFIG_ARM_LPAE=y",
  <LI>"CONFIG_CEPH_FS=m", 
  <LI>"CONFIG_CEPH_LIB=m", 
  <LI>"CONFIG_BLK_DEV_RBD=m", 
  <LI>"CONFIG_VIRTUALIZATION=y". 
</OL>

We then execute the following commands to generate our own .config file.

<PRE>
<hr>
$ cp My-Odroid-Xu4-defconfig /tmp/linux_odroid 
$ cd /tmp/linux_odroid 
$ make ARCH=arm My-Odroid-Xu4-defconfig
Nothing to be done for 'My-Odroid-Xu4-defconfig'.
$ cp My-Odroid-Xu4-defconfig .config 
$ make ARCH=arm menuconfig
# From Device Drivers > Block devices: Check Rados block device set to M
# From File systems > Network File Systems: Check Ceph distributed file system set to M 
#                (module) and turn on the next two Ceph options
# From Virtualization: Turn on all 4 options provided.
<hr>
</PRE>

<PRE>
# $ cd linux_odroid
# $ make ARCH=arm exynos_defconfig
$ make prepare modules_prepare
$ make -j6 bzImage modules dtbs
</PRE>


<p>Copy .dtb to /media/boot - don't overwrite the old one, if one exists.</p>


<PRE>
sudo cp arch/arm/boot/dts/exynos5422-odroidxu4.dtb /media/boot/exynos5422-odroidxu4_next.dtb
</PRE>



<p>Copy zImage to /media/boot - don't overwrite the old one.</p>


<PRE>
$ sudo cp arch/arm/boot/zImage /media/boot/zImage_next
</PRE>


<p>Install modules - will be installed under /lib/modules</p>


<PRE>
$ sudo make modules_install
</PRE>


<p>Install live-boot:</p>


<p> Without <a href="https://packages.debian.org/sid/misc/live-boot" 
target="_b">live-boot</a>, initramfs will not have live support and kernel won't boot. 
You have only once when the first kernel is built.</p>


<PRE>
$ sudo apt-get install live-boot
</PRE>


<h4>Update Initramfs:</h4>


<p> Backup everything in /media/boot to a back-up directory, just in case you run into 
problems. All of the remaining steps need to be run with super user privileges. Copy the 
current .config to  /boot, and then run update-initramfs.</p>


<p><strong>Note:</strong> you should run <em>cat include/config/kernel.release</em> 
separately and copy/paste the results where it is used in the next commands.</p>


<PRE>
$ cp .config /boot/config-`cat include/config/kernel.release`
$ update-initramfs -c -k `cat include/config/kernel.release`
$ mkimage -A arm -O linux -T ramdisk -C none -a 0 -e 0 -n uInitrd -d 
/boot/initrd.img-`cat include/config/kernel.release` /boot/uInitrd-`cat 
include/config/kernel.release`
</PRE>


<p>Copy new uInitrd to /media/boot:</p>


<PRE>
$ cp /boot/uInitrd-`cat include/config/kernel.release` /media/boot/
</PRE>


<p>Now comes the important step to change the boot.ini to boot the new kernel. Edit 
/media/boot/boot.ini and comment out the following line:</p>


<PRE>
#setenv bootcmd "fatload mmc 0:1 0x40008000 zImage; fatload mmc 0:1 0x42000000 \
uInitrd; fatload mmc 0:1 0x44000000 exynos5422-odroidxu3.dtb; bootz \
0x40008000 0x42000000 0x44000000"
</PRE>


<p>Past the new bootcmd line point to new zImage, uInitrd, and dtb files after the line 
you just commented out:</p>

<PRE>
setenv bootcmd "fatload mmc 0:1 0x40008000 zImage_next; fatload mmc 0:1 \
0x42000000 uInitrd-4.7.0-rc2-next-20160608; fatload mmc 0:1 0x44000000 \
exynos5422-odroidxu4_next.dtb; bootz 0x40008000 0x42000000 0x44000000"
</PRE>


<p> We are now at the final step. Run sync and then power the device down and power back 
up. Please remember to disconnect HDMI so it doesn't continue to supply power.</p>


<PRE>
$ sync; poweroff
</PRE>


<p>You should have the newly built zImage running when Odroid boots up. uname -a should 
show that the Linux odroid 4.7.0-rc2-next-20160608 is running.</p>


<p>Please watch out for the following in the dmesg:</p>


<PRE>
FAT-fs (mmcblk1p1): Volume was not properly unmounted. Some data may be corrupt. Please run fsck.
</PRE>


<p> Adding new kernel files (zImage, uInitrd, and exynos5422-odroidxu4.dtb), and 
changing boot.ini work just fine on the boot partition /dev/mmcblk1p1. If you were to 
remove files, please make sure to run fsck on this device. Run the following as root, 
if you don't the system won't boot and it will hang, unable to load the uInitrd.</p>


<PRE>
umount /dev/mmcblk1p1
fsck /dev/mmcblk1p1
mount /dev/mmcblk1p1 /media/boot
</PRE>


<p> There are a few issues I'm still working to solve. Chromium included in the Ubuntu 
16.04 release doesn't work and needs to be downgraded to rev 48.0. After the downgrade, 
Chromium starts, but dies right away. This is a work in progress at the moment. 
Otherwise, configuring and getting mainline kernel booting on Odroid-xu4 has been fun, 
and I hope you find this guide to be valuable.</p>


<h5>About <a href="https://blogs.s-osg.org/author/shuahkh/" title="Shuah Khan">Shuah 
Khan</a></h5>

<p> Shuah Khan is a Senior Linux Kernel Developer at Samsung's Open Source Group. She is 
a Linux Kernel Maintainer and Contributor who focuses on Linux Media Core and Power 
Management. She maintains Kernel Selftest framework. She has contributed to IOMMU, and 
DMA areas. In addition, she is helping with stable release kernel testing. She authored 
Linux Kernel Testing and Debugging paper published on the Linux Journal and writes Linux 
Journal kernel news articles. She has presented at several Linux conferences and Linux 
Kernel Developer Keynote Panels. She serves on the Linux Foundation Technical Advisory 
Board. Prior to joining Samsung, she worked as a kernel and software developer at HP and 
Lucent.</p>


<p>Image Credits: <a href="https://commons.wikimedia.org/wiki/File:XU4packagem.jpg" 
target="_b">Alexandre.willame (CC-BY-SA-4.0)</a></p>            

<p id="cat-tags">
<a href="https://blogs.s-osg.org/category/development/">Development</a> / 
<a href="https://blogs.s-osg.org/category/embedded-technology/">Embedded 
Technology</a> / <a href="https://blogs.s-osg.org/category/linux/">Linux</a>
<a href="https://blogs.s-osg.org/tag/kernel/">Kernel</a>  / 
<a href="https://blogs.s-osg.org/tag/odroid-xu4/">ODROID-XU4</a> </p>			

<h4 id="comments">Comments</h4>       

<ul>
  <li id="comment-243">

      <cite>jobenvil</cite> says:		
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-243">June 11, 2016 at 3:14 am</a>	

      <p>Shuah,<br> thanks for this great guide -your comments regarding many issues, 
      like power off without HDMI and so on- are really apreciated. I was aware of some 
      of these, but is nice to hear that someone else confirmed it.</p>


<p> @wildcats_paris from ARMBIAN forum told me to check your guide, after the short one 
posted in tweter by your friend @Luisbg didn't work -let's say for me-. We will be very 
happy if you share with the community your advantages on this matter.</p>


<p>Hopefully we get more such interesting XU4 feedbacks!</p>


<p>Sincerely</p>

<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=243#respond">Reply</a></div></li><!-- #comment-## -->
  <li id="comment-244">

			<cite>Sebastian</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-244">
			June 16, 2016 at 8:20 pm</a>		</div>

		<p>What a wonderful HowTo. I tried building my own kernel several 
times, but some keys-points were missing. Now it worked right out of the
 box. Thank you !</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=244#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
  <li id="comment-245">

		<cite>Sylvain Munaut</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-245">
			June 21, 2016 at 10:57 am</a>		</div>

		<p>If you go to mainline kernel and 16.04, is the OpenGL ES 
acceleration working ? And ideally working better than in default image ?
 (OpenGL ES windowed mode is abysmal ...)</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=245#respond">Reply</a></div>
				</div>
<ul>
  <li id="comment-246">

		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-246">
			June 21, 2016 at 11:47 am</a>		</div>

		<p>I haven't tried OpenGL ES acceleration on Odroid-xu4 yet. Please 
feel free elaborate on what you have tried so far. Is it worse than 
Oxroid-xu3?</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=246#respond">Reply</a></div>
				</div>
<ul>
  <li id="comment-247">

	<cite>Sylvain Munaut</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-247">
			June 23, 2016 at 4:24 pm</a>		</div>

		<p>I only tried the official kernel from odroid so far.</p>


<p>wrt to OpenGL-ES perf, this was a general comment. The problem is 
that there is a missing link between the 3D (Mali) and the actual 
display on-screen. The 3D engine only outputs the image to an offscreen 
buffer and then that buffer has to actually be copied to the displayed 
framebuffer to show it. Ideally on the Exynos, you'd want that copy to 
be HW accelerated using the G2D, unfortunately there is no code that 
does that. So you end up with a fast 3D engine that renders off-screen 
quickly and is then blitted on the frame buffer via a 'memcpy' at 
incredibly slow speeds ...</p>


<p>ARM provides the skeleton xf86-video-armsoc but that driver is only a
 skeleton that doesn't accelerate anything and must be "filled-in" by 
the SoC vendor to use whatever 2D acceleration they have on the chip 
(the G2D here), but nobody has done that. The one used in the odroid is 
purely relying on software blitting / filling. ( don't be fooled by the 
package name xserver-xorg-video-armsoc-exynos  the exynos here is purely
 how to drive the DRM/KMS but doesn't do any acceleration )</p>


<p>I've actually just found an effort to write such a G2D accelerated xf86-video-armsoc ( <a href="https://github.com/tobiasjakobi/xf86-video-armsoc">https://github.com/tobiasjakobi/xf86-video-armsoc</a>
 ) but it's currently targeted at the "older" U3 and the author has his 
own updated 4.5 kernel tree because this driver depends on newer code / 
interfaces / bug fixes in the G2D DRM driver that are not on the XU4 
3.10 tree from hardkernel.</p>


<p>So being able to run a recent kernel with all those DRM improvements 
to the G2D driver would potentially allow to use that G2D accelerated 
armsoc driver and provide a great perf boost ( glmark2 Score: 258 with 
accel vs 53 without during a preliminary test ! ).</p>


<p>But that implies having mali driver ... which is not in mainline and so
 needs to be patched in. Question is does that patch exist ?<br>
Same question for other features : what are the limitation of mainline ? Is BIG.little / HMP working ?</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=247#respond">Reply</a></div>
				</div>
<ul>
  <li id="comment-248">

	<cite>Sylvain Munaut</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-248">
			June 24, 2016 at 9:15 am</a>		</div>

		<p>Well there you go ... no mali support at all in mainline and the 
"source" published by ARM are not complete, you need some SoC / platform
 code and AFAIK that just doesn't exist for mainline kernel. So no mali 
makes it a bit useless ...</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=248#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
  <li id="comment-250">

<cite><a href="http://calgarysolarcar.ca/">Enoch Tsang</a></cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-250">
			June 29, 2016 at 8:46 pm</a>		</div>

		<p>Your guide was pretty great, explanations were great <img src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" width="20" height="20"> Definitely learned a few things, thanks for taking the time to make this.</p>


<p>At that, after following your guide I lost HDMI output, I'm using this one <a href="https://www.adafruit.com/products/1933">https://www.adafruit.com/products/1933</a>.
 Other than your guide I also enabled DisplayLink support with make 
menuconfig. I also changed a few settings in the boot.ini file but no 
dice.</p>


<p>Any ideas on what might be causing an issue?</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=250#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
  <li id="comment-261">

		<cite><a href="http://uonlibrary.uonbi.ac.ke/">MSOMI</a></cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-261">
			July 2, 2016 at 12:37 am</a>		</div>

		<p>Is ODROID-XU4 open source hardware?</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=261#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
  <li id="comment-278">

<cite><a href="https://blogs.s-osg.org/video-decoding-exynos-multi-format-codec-gstreamer/">Video Decoding with the Exynos Multi-Format Codec &amp; GStreamer - Samsung Open Source Group Blog</a></cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-278">
			September 1, 2016 at 11:11 am</a>		</div>

		<p>[...] how to cross compile and install a mainline kernel on different
 Exynos-based machines, including Exynos5 Odroid boards and Exynos5 
Chromebooks, so refer to these to learn how to do [...]</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=278#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
  <li id="comment-283">

	<cite>clafar</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-283">
			September 23, 2016 at 5:06 am</a>		</div>

		<p>Hi, Thank you very much for this useful guide. I was wondering if 
MFC encoder and I2C work using this kernel. And what are the advantages 
of this kernel versus the official 3.10 kernel provided by odroid?</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=283#respond">Reply</a></div>
				</div>
<ul>
  <li id="comment-304">

		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-304">
			October 26, 2016 at 9:07 am</a>		</div>

		<p>I haven't played with MFC encoder on it. As per advantages over 
3.10, it depends on your use-case. I am using the Odroid XU4 for kernel 
development. Depending on your use-case, you might be just fine with 
3.10 kernel.</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=304#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
  <li id="comment-300">

	<cite>Patrick</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-300">
			October 25, 2016 at 7:08 pm</a>		</div>

		<p>after I followed the instruction here and rebooted the odroid would be stuck at this line on boot</p>


<p>random: crng init done</p>


<p>Do you know what could be the issue here?</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=300#respond">Reply</a></div>
				</div>
<ul>
  <li id="comment-303">

		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-303">
			October 26, 2016 at 9:03 am</a>		</div>

		<p>Looks like it can't mount the rootfs. Please see dmesg from a good boot.</p>


<p>[    4.773544] r8152 5-1:1.0 eth0: v1.08.6<br>
[    5.203080] r8152 5-1:1.0 enx001e0630385e: renamed from eth0<br>
[    5.281049] random: crng init done<br>
[    5.336678] EXT4-fs (mmcblk1p2): mounted filesystem without journal. Opts: (null)</p>


<p>Please check to see if your /media/boot/boot.ini -<br>
setenv bootrootfs<br>
setenv bootcmd</p>


<p>are correct. You don't have to touch the setenv bootrootfs and have 
to update setenv bootcmd to point to the right uInitrd. Also, run fsck 
to make sure there are no errors on the MicroSD.</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=303#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
  <li id="comment-308">

		<cite>Dheeraj</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-308">
			October 31, 2016 at 9:42 am</a>		</div>

		<p>Dear Shuah Khan,<br>
Fuirst of all thanks a lot for the wonderful documentation.<br>
I am using ODROID XU4 and  I followed each and every instructions you 
have written for Kernle compilation. Unfortunately after the kernel 
update, my ODROID XU4 is not booting at all.  but nothing comes up after
 complete power down and power up but The blue light is flashing. My 
humble request to help me in this reagrd.<br>
Thanks in advance for your help!!</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=308#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
  <li id="comment-309">

		<cite>Dheeraj</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-309">
			November 1, 2016 at 9:11 am</a>		</div>

		<p>one more thing to share:<br>
If i switch my setenv bootcmd to old one... odroid boots but then it will get stuck at "freeing unsued kernel" then after sometime</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=309#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
  <li id="comment-310">

		<cite>Dheeraj</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-310">
			November 1, 2016 at 9:11 am</a>		</div>

		<p>after sometime again everything goes blank <img src="https://s.w.org/images/core/emoji/2.2.1/svg/1f641.svg" width="20" height="20"> I don't know how to tackle this <img src="https://s.w.org/images/core/emoji/2.2.1/svg/1f641.svg" width="20" height="20"></p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=310#respond">Reply</a></div>
				</div>
<ul>
  <li id="comment-311">

		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-311">
			November 2, 2016 at 2:03 pm</a>		</div>

		<p>Do you have serial console connected? It is possible, your boot 
partition git corrupted. Running fsck will help. Stating the obvious, 
you will have to run fsck on a different system. I think you are running
 into an early boot issue, it will be lot easier to debug if you have 
serial console.</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=311#respond">Reply</a></div>
				</div>
<ul>
  <li id="comment-326">

	<cite>Dheeraj</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-326">
			November 17, 2016 at 11:53 pm</a>		</div>

		<p>Dear Shuah Khan,<br>
Thanks a ton for your guidence <img src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" width="20" height="20"><br>
As you said, with serial console, the new kernel is running and it's good.<br>
But it doesnt work with HDMI. I request you to give any suggestions as to how can proceed for a solution to work with HDMI.<br>
Thanks a lot again <img src="https://s.w.org/images/core/emoji/2.2.1/svg/1f642.svg" width="20" height="20"></p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=326#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
  <li id="comment-313">

	<cite>hans</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-313">
			November 8, 2016 at 5:32 pm</a>		</div>

		<p>am following your description to produce a bootable SD-Card (it's a 8 GB Class 10).<br>
dd if=/dev/zero of=/dev/sdj1 count=8192 bs=4M<br>
dd if=ubuntu-15.10-mate-odroid-xu3-20160114.img of=/dev/sdj1<br>
Now calling fdisk /dev/sdj1 and what I see is that :<br>
/dev/sdj1        8192 15597567 15589376  7,4G  b W95 FAT32<br>
I cannot see a linux-Partition. Is anything wrong here ? Or how I have to prepair the microSD-Card ?<br>
Would be very grateful do help.<br>
Thank you very much</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=313#respond">Reply</a></div>
				</div>
<ul>
  <li id="comment-336">

		<cite>moztr</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-336">
			January 6, 2017 at 12:30 am</a>		</div>

		<p>hans, the "of" you've selected is the first partition of sdj - 
presumably the SD-card you want to write to. However, you need to write 
to the SD-card directly (you will loose ALL data on that device!). So, 
assuming that your sd-card is on /dev/sdj, "dd 
if=ubuntu-15.10-mate-odroid-xu3-20160114.img of=/dev/sdj" should do the 
trick. By the way, the zeroing you did is just to wipe any previously 
written data, also, you've supplied dd with a count and a blocksize ... so
 it'll copy 8192 blocks of 4mbyte size, so that's 32gbyte. with sdj1 
being apparently 8gbyte in size, that command should have produced an 
error.</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=336#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
</ul><!-- .children -->
</li><!-- #comment-## -->
  <li id="comment-324">

	<cite>Naoufel</cite> says:		</div>
		
<a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/#comment-324">
			November 17, 2016 at 11:15 am</a>		</div>

		<p>Dear Shuah Khan,</p>


<p>Thank you for these shares</p>

		<div><a href="https://blogs.s-osg.org/install-ubuntu-run-mainline-kernel-odroid-xu4/?replytocom=324#respond">Reply</a></div>
				</div>
		</li><!-- #comment-## -->
	    		    </ul>        
<hr>


<a name="GetMoreOutOfUboot"></a>
<h3>Get more out of "Das U Boot" 
<a href="https://github.com/umiddelb/armhf/wiki/Get-more-out-of-%22Das-U-Boot%22" 
target="_b">(Source Origin)</a></h3>

<div class="gh-header-meta">
  leonklingele edited this page <relative-time title="Jan 1, 2017, 5:47 AM GMT+8" 
datetime="2016-12-31T21:47:05Z">on Jan 1, 2017</relative-time> 
</div>

<h3>Synopsis</h3>

<p>The majority of recent ARM based devices use "Das U-Boot" (u-boot) to load and start 
the Linux kernel. Many vendors focus on an end-user friendly u-boot configuration. 
If you need more flexibility, it is worth a deeper look into the u-boot internal 
structure</p>

<p>The people from the ODROID Magazine kindly published this artice in their 
<a href="http://forum.odroid.com/viewtopic.php?f=7&amp;t=17263">2015-11 issue</a>. </p>

<h3>What is u-boot?</h3>

<p>U-boot is a boot loader similar to <a href="http://lilo.alioth.debian.org/">lilo</a> 
or <a href="https://www.gnu.org/software/grub/">grub</a>, but is specifically designed 
for embedded devices. U-boot is maintained by 
<a href="http://www.denx.de/wiki/U-Boot/WebHome">denx</a> and published under the GNU 
General Public License version 2 (GPL-2.0+). Compared to grub, u-boot doesn't offer a 
high level of selfconfiguration or end-user friendliness, but it does offer a much 
smaller footprint. </p>

<p>The most convenient way to interact with u-boot is via serial console. Many ARM 
devices offer serial access via USB, which makes it easy to manage console access. Just 
connect the serial console via USB to another Linux box,  and you have remote serial 
access to your ARM device. To do so, log in to your Linux box via ssh and open the 
serial connection via minicom(1):</p>

<pre>
<code>sudo minicom -b 115200 -D /dev/ttyUSB0
</code>
</pre>

<p>Press <code>^A z</code> to open the interactive help/configuration screen, press 
<code>^A x</code> to exit your minicom session. </p>

<p><code>minicom</code> isn't the only terminal emulator for serial access, screen(1) 
and picocom(8) are popular alternatives:</p>

<pre>
<code>sudo picocom -b 115200 /dev/ttyUSB0
</code>
</pre>

<p>Press <code>^A ^X</code> to exit your picocom session.</p>

<h3>The boot process</h3>

<p>When a device gets powered on, it has to go through various initialization stages 
before you see the operating system login prompt or desktop.  </p>

<h3>Stage 1 (Secondary Program Loader / SPL)</h3>

<p>The first stage of the boot process is the Secondary Program Loader (SPL).  This 
preliminary piece of code is responsible for board initialization, loading the u-boot 
binary ("secondary program") and handling the control flow over to the u-boot main 
program.  It is device specific, and is often provided as a closed source binary blob 
by the SoC vendor.</p>

<p>The secondary program loader (SPL) and the u-boot binary reside in a special on-board 
flash memory region or on the first sectors of the uSD/eMMC card.  ODROID devices use 
microSD or eMMC modules for storing the SPL and u-boot binary. The individual disk 
regions are detailed in the disk layout and <a href="#disk-layout-and-partitioning" 
target="_b">partitioning section</a> below.</p>

<h3>Stage 2 (u-boot)</h3>

<p>At the second stage of the boot process, the u-boot main program is executed.  U-boot 
first looks for a custom environment stored at a reserved space on the microSD or eMMC 
module, or falls back to the compile-time default environment if needed.  At this time, 
you can interrupt the automatic boot process by pressing a key on your serial console, 
which starts an interactive u-boot shell.  The u-boot variable called 
<code>bootdelay</code> specifies the number of seconds to wait for a keypress before 
continuing automatic boot.</p>

<pre>
<code>CPU : AMLogic S805
MEM : 1024MB (DDR3@792MHz)
BID : HKC13C0001
S/N : HKC1CC037EBCBFA4
0x0000009f
Loading U-boot...success.


U-boot-00000-geb22ea4-dirty(odroidc@eb22ea4b) (Jul 28 2015 - 22:16:46)

DRAM:  1 GiB
relocation Offset is: 2ff1c000
MMC:   eMMC: 0, SDCARD: 1
IR init is done!
vpu clk_level = 3
set vpu clk: 182150000Hz, readback: 182150000Hz(0x701)
mode = 6  vic = 4
set HDMI vic: 4
mode is: 6
viu chan = 1
config HPLL
config HPLL done
reconfig packet setting done
MMC read: dev # 0, block # 33984, count 12288 ... 12288 blocks read: OK
There is no valid bmp file at the given address
============================================================
Vendor: Man 450100 Snr 01172c20 Rev: 4.7 Prod: SDW16
            Type: Removable Hard Disk
            Capacity: 15028.0 MB = 14.6 GB (30777344 x 512)
------------------------------------------------------------
Partition     Start Sector     Num Sectors     Type
    1                 3072          524288       b
    2               527360        14680064      83
    3             15207424        15569920      83
============================================================
Net:   Meson_Ethernet
init suspend firmware done. (ret:0)
Hit Enter key to stop autoboot -- :  3 tstc enter

exit abortboot: 1
odroidc#
</code>
</pre>

<p>The automatic boot process executes a special u-boot macro called 
<code>bootcmd</code>, which loads and executes the following procedures:</p>

<ol>
  <li>(opt.) a custom u-boot environment: <code>uEnv.txt</code></li>
  <li>(opt.) a precompiled u-boot macro: <code>boot.scr</code></li>
  <li>the kernel image, e.g. <code>uImage</code></li>
  <li>(opt.) the device tree binary, e. g. <code>meson8b_odroidc.dtb</code></li>
  <li>(opt.) the initial ramdisk, e. g. <code>uInitrd</code></li>
</ol>

<h3>Stage 3 (Linux kernel)</h3>

<p>The third stage is the loading of the Linux kernel.  However, before the Linux kernel 
takes control, u-boot passes a command line to the kernel containing essential 
parameters.  These parameters can be viewed after the operating system has booted by 
typing the following into a Terminal window:</p>

<pre>
<code>$ cat /proc/cmdline
root=/dev/mmcblk0p2 rootwait rw console=ttyS0,115200n8 console=tty0 no_console_suspend vdaccfg=0xa000 \
  logo=osd1,loaded,0x7900000,720p,full dmfc=3 cvbsmode=576cvbs hdmimode=1080p m_bpp=32 vout=hdmi disablehpd=true
</code>
</pre>

<p>The kernel initializes the hardware, mounts the root filesystem (according to the 
<code>root=...</code> kernel parameter) and passes the control flow to 
<code>/sbin/init</code>. </p>

<h3>The shortcut</h3>

<p>Hardkernel makes use of a special u-boot command called <code>cfgload</code>, which 
bypasses the ordinary boot process and provides a simplified u-boot configuration 
facility in a single file called <code>boot.ini</code>.  Configuration changes can be 
done easily by editing the <code>boot.ini</code> file, rather than modifying the u-boot 
environment, but this extension doesn't provide any access to the interactive u-boot 
shell. </p>

<p>You can boot one configuration at a time only by default. If a particular 
configuration change causes the system to hang during boot, you will need to remove the 
uSD or eMMC module from your device and revert this change by editing 
<code>boot.ini</code> on your notebook or PC.</p>

<h3>Understanding u-boot</h3>

<a name="disk-layout-and-partitioning"></a>
<h3>Disk layout and partitioning</h3>

<p>Many ARM boards use a uSD/eMMC module to store the different u-boot components (SPL, 
u-boot executable, u-boot environment). In contrast to other devices which use flash 
based memory storage for this purpose (tablets, mobiles, ...), you cannot brick your 
device by an unsuccessful firmware update. </p>

<p>The u-boot components are stored on reserved areas of the uSD/eMMC, before the first 
partition starts (all numbers denote the start and the end sector):</p>

<table>
<thead>
<tr>
<th align="left">Area</th>
<th align="right">&nbsp;&nbsp;ODROID-<a href="http://odroid.com/dokuwiki/doku.php?id=en:c1_partition_table">C1(+)</a>
</th>
<th align="right">&nbsp;&nbsp;ODROID-<a href="http://odroid.com/dokuwiki/doku.php?id=en:c2_partition_table">C2</a>
</th>
<th align="right">&nbsp;&nbsp;ODROID-<a href="http://odroid.com/dokuwiki/doku.php?id=en:u3_partition_table">U3</a>/<a href="http://odroid.com/dokuwiki/doku.php?id=en:xu3_partition_table">XU3/XU4</a>
</th>
<th align="right">&nbsp;&nbsp;&nbsp;<a href="http://wiki.solid-run.com/doku.php?id=products:imx6:software:development:u-boot">CuBox-i</a></th>
<th align="right">&nbsp;&nbsp;&nbsp;<a href="https://www.pine64.com/product">PINE64(+)</a></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">SPL (BL1/BL2)</td>
<td align="right">0 -   63</td>
<td align="right">0 -   96</td>
<td align="right">1 -   62</td>
<td align="right">1 -   83</td>
<td align="right">16 - 143</td>
</tr>
<tr>
<td align="left">U-boot executable</td>
<td align="right">64 - 1023</td>
<td align="right">97 -  1431</td>
<td align="right">63 -  718</td>
<td align="right">84 -  767</td>
<td align="right">&nbsp;&nbsp;&nbsp;&nbsp;38192 - 40959</td>
</tr>
<tr>
<td align="left"><strong>U-boot environment</strong></td>
<td align="right"><strong>1024 - 1087</strong></td>
<td align="right"><strong>1440 - 1503</strong></td>
<td align="right"><strong>1231 - 1262</strong></td>
<td align="right">&nbsp;&nbsp;&nbsp;&nbsp;<strong>768 - 783</strong></td>
<td align="right"><strong>file based</strong></td>
</tr>
<tr>
<td align="left">1st partition</td>
<td align="right">3072 -  ...</td>
<td align="right">3072 -  ...</td>
<td align="right">3072 -  ...</td>
<td align="right">2048 -  ...</td>
<td align="right">40960 - ...</td>
</tr>
</tbody>
</table>

<p>As you can see, there is no common canonical layout for the u-boot components across 
different boards. If you want to modify the partitioning with tools like 
<code>fdisk(8)</code>, you may keep in mind that <code>fdisk</code> always tries to 
create new partitions starting from sector 2048 by default.</p>

<p>U-boot tries to load the kernel image and additional files from the first partition 
of the designated boot device. Earlier u-boot versions supported only the vfat file 
system, which resulted in this typical partition layout:</p>

<table>
<thead>
<tr>
<th>device</th>
<th>label&nbsp;&nbsp;&nbsp;</th>
<th>filesystem&nbsp;&nbsp;&nbsp;</th>
<th>mount point&nbsp;&nbsp;</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/dev/mmcblk0p1&nbsp;&nbsp;</code></td>
<td>boot</td>
<td>vfat</td>
<td><code>/media/boot</code></td>
</tr>
<tr>
<td><code>/dev/mmcblk0p2</code></td>
<td>rootfs</td>
<td>ext4</td>
<td><code>/</code></td>
</tr>
</tbody>
</table>

<p>Recent u-boot versions support reading files from ext4 file-systems, so there is no 
technical need to stick to the vfat boot partition.  Although many installer images keep 
on using it due to convenience reasons, e.g. editing <code>boot.ini</code> on Windows / 
OS X which don't support ext4 out of the box.</p>

<h3>u-boot commands</h3>

<p>The interactive u-boot shell offers a set of commands, depending on version and patch 
level. You can get a list of all supported commands by typing</p>

<pre>
<code>help
</code>
</pre>

<p>and</p>

<pre>
<code>help &lt;command&gt;
</code>
</pre>

<p>For further information please refer to the very extensive <a target="_b" 
href="http://www.denx.de/wiki/view/DULG/UBootCommandLineInterface">official 
documentation</a>. </p>

<h3>u-boot environment</h3>

<p>The u-boot environment stores a set of variables in the form 
<code>&lt;variable&gt;=&lt;value&gt;</code>.  If a saved environment is available 
u-boot initializes the working environment with these values or falls back to the 
built-in default environment. Variables are referenced by <code>${variable}</code>.</p>

<pre>
<code>printenv
</code>
</pre>

<p>prints out the whole set of variables, whereas</p>

<pre>
<code>printenv variable
</code>
</pre>

<p>prints the value of a single variable</p>

<pre>
<code>setenv variable value
</code>
</pre>

<p>sets a certain variable with the designated value </p>

<pre>
<code>setenv variable
</code>
</pre>

<p>deletes a variable from the environment</p>

<pre>
<code>env -a
</code>
</pre>

<p>resets the u-boot environment with the built-in defaults</p>

<pre>
<code>saveenv
</code>
</pre>

<p>stores the current environment on the uSD or eMMC module. You can also 
<a href="https://github.com/umiddelb/armhf/wiki/Get-more-out-of-%22Das-U-Boot%22#userland-access-to-the-u-boot-environment">read 
and modify the u-boot environment</a> when the system has started Linux.</p>

<h3>u-boot macros</h3>

<p>U-boot uses variables to store scripts, so </p>

<pre>
<code>setenv macro '...;'
</code>
</pre>

<p>will define a variable called <code>macro</code> containing a list of commands, 
delimited by a semicolon (<code>;</code>). Macros may be invoked by typing the "run" 
command:</p>

<pre>
<code>run macro
</code>
</pre>

<p>The most prominent macro is <code>bootcmd</code> which is run by default. Macros 
return a value (the return value of the command executed at last) which can be evaluated 
by an <code>if ... ; then ... ; else ...;</code> clause. Additional information is 
'returned' by modifying specific variables, e.g. the <code>load</code> command uses 
the (global) variable <code>filesize</code> to return the number of bytes read from 
disk.</p>

<h3>Typical boot sequence</h3>

<p>The macro <code>bootcmd</code> implements the boot sequence, executed in 
non-interactive mode. Prior to executing <code>bootcmd</code>, u-boot initializes the 
u-boot environment containing the configuration variables and macros. The typical steps 
inside <code>bootcmd</code> are:</p>

<h4>Load a custom environment from the boot partition</h4>

<p><code>bootcmd</code> looks for a text file called <code>uEnv.txt</code>
 on the boot partition, loads it and merges its contents with the 
existing u-boot environment by overriding values of existing variables. 
This step is optional.</p>

<h4>Load a custom environment from the boot partition</h4>

<p><code>bootcmd</code> will then look for a file called <code>boot.scr</code> on the 
boot partition, load the file and execute its contents without returning back to 
<code>bootcmd</code>. <code>boot.scr</code> contains compiled u-boot commands in a 
binary format. This step is optional.</p>

<h4>Load the kernel image from the boot partition</h4>

<p><code>bootcmd</code> looks for the kernel image. The u-boot variable 
<code>kernel</code> contains the actual filename, usually <code>zImage</code>. You can 
boot an alternate kernel image by changing the variable <code>kernel</code>.</p>

<h4>Load the device tree binary from the boot partition</h4>

<p>The Linux kernel on ARM needs a low level device description (device tree) in binary 
format, either appended to the kernel image or as a separate file. Many platforms prefer 
loading the device tree binary as a separate file, which offers more flexibility, 
allowing distribution of a single installation image for different platforms, or 
tweaking of the device tree for different use cases. Some vendors let 
<code>bootcmd</code> decide on the actual device tree binary to load, depending on the 
board discovery performed by u-boot.</p>

<h4>Load the initial ramdisk archive from the boot partition</h4>

<p>The bootcmd macro will finally try to load the initial ramdisk archive from a file 
called <code>uInitrd</code>.  This archive is created and updated by using the 
update-initramfs utility, which is usually done when a new kernel image has been 
installed. This step is optional.</p>

<h3>Userland access to the u-boot environment</h3>

<p>When the system has booted up you can still modify the u-boot environment. The Ubuntu 
package <code>u-boot-tools</code> contains fw_printenv(8) and fw_setenv(8) for accessing 
the stored u-boot environment. After installing the package with </p>

<pre>
<code>sudo apt-get -y install u-boot-tools
</code>
</pre>

<p>you need to configure the storage device and address information in the file 
<code>/etc/fw_env.config</code>, e.g. for the ODROID-C1:</p>

<pre>
<code># &lt;device&gt;   &lt;offset&gt; &lt;length&gt;
/dev/mmcblk0 0x80000   0x8000
</code>
</pre>

<p>and for the ODROID-XU3/XU4:</p>

<pre>
<code># &lt;device&gt;   &lt;offset&gt; &lt;length&gt;
/dev/mmcblk0 0x99E00   0x4000
</code>
</pre>

<p>You can test the configuration with </p>

<pre>
<code>sudo fw_printenv bootdelay
</code>
</pre>

<p>The u-boot environment stored on disk contains a CRC checksum. If offset/length 
doesn't match you will receive a warning, like:</p>

<pre>
<code>Warning: Bad CRC, using default environment
</code>
</pre>

<p>To create an environment that can be modified with <code>u-boot-tools</code> halt the 
boot process during the early u-boot phase (you'll need to do this via an attached 
serial connection). At the u-boot prompt type 'saveenv'. u-boot will reply with a 
message of confirmation. Then <code>reset</code> to boot. When you next try 
<code>sudo fw_printenv</code> you should get a listing without the warning.</p>

<h4>Important</h4>

<p>Do not attempt to modify the u-boot environment if you are getting 
the CRC error. In all likelihood you will render your device unbootable.</p>

<h3>Typical use cases for the ODROID C1</h3>

<p>By default the ODROID-C1 is configured to boot via <a href="https://github.com/umiddelb/armhf/wiki/Get-more-out-of-%22Das-U-Boot%22#the-shortcut"><code>cfgload</code></a> 
with a very short boot delay. Increasing u-boot variable <code>bootdelay</code> gives 
you the chance to interrupt the automated boot process. You can use fw_setenv(8) to 
assign a new value to <code>bootdelay</code>:</p>

<pre>
<code>sudo fw_printenv bootdelay
sudo fw_setenv bootdelay 3
</code>
</pre>

<p>prints the current value and sets the delay to 3 seconds.</p>

<h3>Boot an alternative kernel image</h3>

<p>If you compile your own kernel from source, you really want to test the new kernel 
before overwriting the current one or keep a known working kernel as backup. Booting a 
different than the default kernel can be done by defining an u-boot macro which refers 
to different files on the boot partition. </p>

<pre>
<code>sudo setenv m_boot_ 'setenv bootargs "root=/dev/mmcblk0p2 rootwait rw console=ttyS0,115200n8 console=tty0 no_console_suspend \
  vdaccfg=0xa000 logo=osd1,loaded,0x7900000,720p,full dmfc=3 cvbsmode=576cvbs hdmimode=1080p m_bpp=32 vout=hdmi disablehpd=true"; \
  fatload mmc 0:1 0x21000000 _uImage;fatload mmc 0:1 0x22000000 uInitrd; fatload mmc 0:1 0x21800000 _meson8b_odroidc.dtb; \
  fdt addr 21800000; fdt rm /mesonstream; fdt rm /vdec; fdt rm /ppmgr; fdt rm /mesonfb; bootm 0x21000000 0x22000000 0x21800000'
</code>
</pre>

<p>This defines the u-boot macro <code>m_boot_</code> which refers to the kernel image 
<code>_uImage</code> and the device binary <code>_meson8b_odroidc.dtb</code>.
 Unfortunately u-boot doesn't allow line feeds inside macros which makes them hard to 
read. If you insert a line feed after each <code>;</code> you will see the same command 
sequence as in <code>boot.ini</code>:</p>

<pre>
<code>setenv bootargs "root=/dev/mmcblk0p2 rootwait rw console=ttyS0,115200n8 no_console_suspend vdaccfg=0xa000 \
  logo=osd1,loaded,0x7900000,720p,full dmfc=3 cvbsmode=576cvbs hdmimode=1080p m_bpp=32 vout=hdmi disablehpd=true";
fatload mmc 0:1 0x21000000 _uImage;
fatload mmc 0:1 0x22000000 uInitrd;
fatload mmc 0:1 0x21800000 _meson8b_odroidc.dtb;
fdt addr 21800000;
fdt rm /mesonstream; 
fdt rm /vdec; 
fdt rm /ppmgr; 
fdt rm /mesonfb; 
bootm 0x21000000 0x22000000 0x21800000';
</code>
</pre>

<p>This is the effective command sequence during boot when configuring 
<code>boot.ini</code> to a headless configuration:</p>

<pre>
<code>setenv vout_mode "hdmi"
setenv m_bpp "32"
setenv hpd "0"
setenv cec "0"
setenv vpu "0"
setenv hdmioutput "0"
</code>
</pre>

<p>Once you have defined the macro <code>m_boot_</code> and copied the kernel image and 
device tree binary to the boot partition with a leading '_' in the filename you can boot 
this kernel by interrupting u-boot and typing</p>

<pre>
<code>run m_boot_
</code>
</pre>

<p>at the u-boot shell prompt. </p>

<h3>boot rootfs from a different partition, e.g from USB disk</h3>

<p>You might have noticed the kernel parameter <code>root=...</code> which u-boot passes 
to the Linux kernel. The kernel will try to mount the root filesystem (<code>/</code>) 
from there. The root filesystem can be adressed in different ways:</p>

<ul>
  <li>via device node: e.g. <code>root=/dev/sda1</code></li>
  <li>via UUID filesystem identifier: e.g. 
      <code>root=UUID=e139ce78-9841-40fe-8823-96a304a09859</code></li>
</ul>

<p>If you have only one USB storage device connected to your board you can safely 
address the root filesystem via device node. If you plan to dynamically connect/remove 
additional storage devices you're better off by addressing the root filesystem via the 
UUID identifier, otherwise the kernel might miss the root filesystem due to a 
'forgotten' USB stick during next boot.</p>

<p>You can read the available UUIDs via <code>blkid</code>:</p>

<pre>
<code>$ sudo blkid
/dev/mmcblk0p1: SEC_TYPE="msdos" LABEL="boot" UUID="E26F-2230" TYPE="vfat"
/dev/mmcblk0p2: LABEL="rootfs" UUID="e139ce78-9841-40fe-8823-96a304a09859" TYPE="ext4"
/dev/mmcblk0p3: LABEL="rootfs2" UUID="e139ce78-9841-40fe-8823-96a304a09860" TYPE="ext4"
/dev/sda1: LABEL="rootfs" UUID="e54a458d-6a66-4ed2-9394-7b22d2943ec9" TYPE="ext4"
</code>
</pre>

<p>The UUID can be set while creating a filesystem with <code>mkfs</code>:</p>

<pre>
<code>$ sudo mkfs.ext4 -O ^has_journal -b 4096 -L rootfs -U e54a458d-6a66-4ed2-9394-7b22d2943ec9 /dev/sda1 
</code>
</pre>

<p>If you omit the parameter <code>-U</code> the UUID is chosen ramdomly.</p>

<p>As in the previous section you can define an additional u-boot macro which will then 
pass an alternative root filesystem to the kernel:</p>

<pre>
<code>sudo setenv m_boot_usb 'setenv bootargs "root=/dev/sda1 rootwait rw console=ttyS0,115200n8 console=tty0 no_console_suspend vdaccfg=0xa000 \
  logo=osd1,loaded,0x7900000,720p,full dmfc=3 cvbsmode=576cvbs hdmimode=1080p m_bpp=32 vout=hdmi disablehpd=true"; fatload mmc 0:1 \
  0x21000000 uImage;fatload mmc 0:1 0x22000000 uInitrd; fatload mmc 0:1 0x21800000 meson8b_odroidc.dtb; fdt addr 21800000; fdt rm \
  /mesonstream; fdt rm /vdec; fdt rm /ppmgr; fdt rm /mesonfb; bootm 0x21000000 0x22000000 0x21800000'
</code>
</pre>

<p>Although it is not recommended, if you need to clone the contents of a mounted root 
filesystem you may perform a bind mount before copying:</p>

<pre>
<code>$ sudo mount /dev/sda1 /media/usb
$ sudo mount -o bind / /mnt
$ cd /mnt
$ sudo find . | sudo cpio -dump /media/usb
$ cd
$ sudo umount /mnt
$ sudo umount /media/usb
</code>
</pre>

<p>Which then allows you to boot from USB by typing the following at the u-boot shell 
prompt:</p>

<pre>
<code>run m_boot_usb
</code>
</pre>

<p>at the u-boot shell. </p>

<h3>References</h3>

<ul>
  <li><a href="http://free-electrons.com/pub/conferences/2015/captronic/captronic-porting-linux-on-arm.pdf">Porting Linux on ARM</a></li>
</ul>



</body></html>
