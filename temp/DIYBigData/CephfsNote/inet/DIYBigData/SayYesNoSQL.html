<!DOCTYPE html>
<html lang="en-US">
  <head><title>Just Say Yes to NoSQL Part i</title>
  </head>
  <body>

<OL>
  <LI><a href="#JustSayYesToNoSQL">Just Say Yes to NoSQL Part 1</a>
  <LI><a href="#ExploringDifferentTypesNoSQL">Exploring the Different Types of NoSQL 
         Databases Part 2</a>
  <LI><a href="#SelectionCriteriaNoSQLDatabase">Selection Criteria for NoSQL Database 
         Part 3</a>  
  <LI><a href="#NoSQLDatabasesComparison">A Comparison Of NoSQL Database Management 
         Systems And Models</a>
  <LI><a href="#"></a>
</OL>

<a name="JustSayYesToNoSQL"></a>
<h3>Just Say Yes to NoSQL Part i 
<a href="https://www.3pillarglobal.com/insights/just-say-yes-to-nosql" 
target="_b">(Source Origin)</a></h3>

</div>


<p>As
 the popularity of data virtualization continues to rise, companies are 
increasingly relying on data storage and retrieval mechanisms like NoSQL
 to extract tangible value out of the voluminous amounts of data 
available today.</p>

<p>This first blog in a 3-part series will explain 
why we believe NoSQL is among the best database technologies for sorting
 vast amounts of data. The second part will explore the different 
categories of NoSQL databases, and the final part will focus on how to 
zero in on the best NoSQL database solution.</p>

<p><strong>Part 1: Reasons in Support of Adopting NoSQL</strong></p>

<p>The
 need for data management has increased over the last few years, owing 
to a surge of interactive web and mobile applications being used by 
enterprises irrespective of their size. Emerging technologies like Big 
Data and Cloud Computing have driven the adoption of NoSQL technology.</p>

<p><strong>Big Data</strong>:</p>

<p>Personal
 user information, geo location data, social media activities, and 
sensor-generated data are just a few examples of the ever-expanding 
array of data being captured. Capturing and interpreting the vast amount
 of structured and unstructured formats of data is now bolstering the 
analytical capabilities of enterprises and enabling to create innovative
 products that power new routes to revenues.</p>

<p>Any changes in the 
content structure can be a cause of concern if the database is rigid and
 cannot accommodate new data types. Developers must be provided with a 
database that is extremely flexible to handle even unstructured formats 
of data which are a norm today and increasingly being used by companies 
for analytical purposes. Relational database management system often use
 a schema-based approach which turns out to be a mismatch when it comes 
to processing unstructured formats of data types. It is precisely here 
that NoSQL comes in handy as it can use varying data types with ease.<br> 

<P><strong>NoSQL </strong>(Not Only SQL)</p>

<p>To
 its advantage, NoSQL works well with distributed data stores such as 
Google and Facebook where large data types are handled and need to be 
stored. Such kind of voluminous data types may not require having join 
operations, fixed schema and horizontal scaling.</p>

<p><strong>Key Characteristics of NoSQL Databases</strong></p>

<p><strong>1. Distributed Computing </strong>(Scalability, Reliability, Sharing of 
Resources, Performance) <strong>- </strong>NoSQL databases are distributed, can scale 
horizontally and handle large data volumes of several terabytes or petabytes, with low 
latency.</p>

<p>The rise in parallel users and the volume of data requires web and mobile 
applications and supporting databases to scale accordingly using, something which can 
be achieved using the following two methods:</p>

<p><strong>a. Vertical Scaling (or scale up) </strong>- This implies adding resources 
to a single node by deploying additional CPU or increasing the memory storage.</p>

<p><strong>Scaling Up with Relational Databases</strong>: To support a large number of 
concurrent users and/or store more data, you need big servers with additional CPUs to 
handle the workload, more memory, and more disk storage to keep all the tables. 
Installing and maintaining big servers is a complex process that also adds to capital 
expenditure, unlike the low-cost, commodity hardware typically used at the 
web/application server tier of RDBMS.</p>

<p><strong>b. Horizontal Scaling (or scale out) </strong>- Scale out is related to 
adding on to the nodes on a system. E.g. - Adding a new computer to a distributed 
software application.</p>

<p><strong>Scale Out with NoSQL Database</strong>: Scaling out takes recourse to a 
cluster of servers for storing data and supporting database operations. They use a 
cluster of servers to store data and support database operations. The cluster is 
expanded by adding additional servers so as to spread the database operations to a 
larger cluster. Since commodity servers are susceptible to failure, NoSQL databases 
are designed to withstand and recover from such recurring failures, making them 
highly resilient.</p>

<p>NoSQL databases provide a much easier, linear approach to database scaling. They 
are best suited to counter a sudden spike in new user activity. To handle unexpected 
spikes in volumes, all one has to do is add a new database server to expand the size 
of the cluster.</p>

<p>2.&nbsp;&nbsp;<strong>More Flexible Data Model </strong><strong>- </strong>NoSQL 
databases follow one of the following data models/stores:</p>

<p>a. Key Value Stores</p>

<p>b. Document Stores</p>

<p>c. Column Based Stores</p>

<p>d. Graph Databases</p>

<p>e. XML Databases</p>

<p>&nbsp;</p>

<p><img src="https://www.3pillarglobal.com/sites/default/files/nosql1.png" alt="NoSQL 
databases Model"><br> 
3.&nbsp;<strong>Asynchronous Inserts &amp; Updates/Weak Transactional -</strong> Full
 transactional guarantees and simultaneous completion of transactions at
 all nodes in the distributed environment are not provided by NoSQL 
databases. Instead it guarantees the availability of the data at the 
distributed level (by some internal process of synchronization). This is
 the reason why NoSQL is a perfect model to apply for instances like 
social media applications where simultaneous transactions are not a 
constraint.</p>

<p>4.&nbsp;<strong>Follows BASE/CAP instead of ACID -</strong>, (Atomicity, 
Consistency, Isolation, Durability). Instead of ACID, NoSQL databases more or less 
follow something called "BASE" (Basically Available, SoftState, Eventual Consistency). 
All NoSQL databases relax one or more of the ACID properties (CAP theorem). For 
example, when no updates occur for a certain period of time (could be few seconds), 
eventually all updates may propagate through the system depending on load, cluster 
size and network traffic which will make all the nodes consistent.</p>

<p>However, eventually consistent tools are hardly applicable in strict scenarios 
like banking applications. In these cases, a good idea could be to use in-memory, 
column-oriented and distributed SQL/ACID databases, like <a href="http://voltdb.com/" 
target="_blank">VoltDB</a>.</p>

<p>5.&nbsp;<strong>Query Language -</strong> These databases <strong>do not support 
SQL </strong>unlike in relational databases. However, few NoSQL databases support some 
other form of query language, like CouchDB uses 
<a href="http://en.wikipedia.org/wiki/JSON" target="_blank">JSON</a> to store data 
and <a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a> 
as its query language.</p>

<p>6.&nbsp;<strong>NoJoins -</strong> NoSQL databases don't use the concept of joins.</p>

<p>7.&nbsp;<strong>Low Cost -</strong> Uses clusters of cheap commodity servers instead 
of proprietary servers to manage the exploding data and transaction volumes.</p>

<p>8.&nbsp;<strong>Easy Implementation -</strong> provides schema flexibility and less 
complicated relationships unlike in RDBMS.</p>

<p>9. Good for scenarios which mostly require querying/searching (but not complex 
search or analytics) and very few or no updates.</p>

<table style="width: 629px;" cellpadding="1" cellspacing="1" border="1">
<tbody>
<tr><td><strong>NoSQL Advantages</strong></td>
    <td style="width: 308px;"><strong>NoSQL Disadvantages</strong></td></tr>
<tr><td>High Scalability</td>
    <td style="width: 308px;">Too many options (Above 150), which one to pick.</td></tr>
<tr><td>Schema Flexibility</td>
    <td style="width: 308px;">Limited query capabilities (so far)</td></tr>
<tr><td>Distributed Computing (Reliability, Scalability, Sharing of Resources, 
        Speed)</td>
    <td style="width: 308px;">Eventual consistency is not intuitive to progran for 
        strict scenarios like banking applications.</td></tr>
<tr><td>No complicated relationships</td>
    <td style="width: 308px;">Lacks Joins, Group by, Order by facilities</td></tr>
<tr><td>Lower cost (Hardware Costs)</td>
    <td style="width: 308px;">ACID transactions</td></tr>
<tr><td>Open Source - All of the NoSQL options with the exceptions of Amazon S3 
        (Amazon Dynamo) are open-source solutions. This provides a low-cost entry 
        point.</td>
    <td style="width: 308px;">Limited guarantee of support - Open source</td></tr>
</tbody>
</table>

<p>&nbsp;</p>

<table style="width: 630px;" cellpadding="1" cellspacing="1" border="1"><tbody>
<tr><td style="width: 100px;"><strong>Feature</strong></td>
    <td style="width: 238px;"><strong>NoSQL</strong></td>
    <td style="width: 274px;"><strong>RDBMS</strong></td></tr>
<tr><td style="width: 100px;"><strong>Data Volume</strong></td>
    <td style="width: 238px;">Handles Huge Data Volumes</td>
    <td style="width: 274px;">Handles Limited Data Volumes</td></tr>
<tr><td style="width: 100px;"><strong>Data Validity</strong></td>
    <td style="width: 238px;">Highly Guaranteed</td>
    <td style="width: 274px;">Less Guaranteed</td></tr>
<tr><td style="width: 100px;"><strong>Scalability</strong></td>
    <td style="width: 238px;">Horizontally</td>
    <td style="width: 274px;">Horizontally &amp; Vertically</td></tr>
<tr><td style="width: 100px;"><strong>Query Language</strong></td>
    <td style="width: 238px;">No declarative query language</td>
    <td style="width: 274px;">Structured Query Language (SQL)</td></tr>
<tr><td style="width: 100px;"><strong>Schema</strong></td>
    <td style="width: 238px;">No predefined schema or less rigid schemas</td>
    <td style="width: 274px;">Predefined Schema (Data Definition Laguage &amp; Data 
        Manipulation Language)</td></tr>
<tr><td style="width: 100px;"><strong>Data Type</strong></td>
    <td style="width: 238px;">Supports unstructured and unpredictable data</td>
    <td style="width: 274px;">Supports relational data and its relationships are stored 
        in separate tables</td></tr>
<tr><td style="width: 100px;"><strong>ACID/BASE</strong></td>
    <td style="width: 238px;">Based on BASE principle (Basically, Available, Soft State, 
        Eventually Consistent)</td>
    <td style="width: 274px;">Based on ACID principle (Atomicity, Consistency, Isolation 
        and Durability)</td></tr>
<tr><td style="width: 100px;"><strong>Transaction Management</strong></td>
    <td style="width: 238px;">Weaker transactional guarantee</td>
    <td style="width: 274px;">Strong transactional guarantees</td></tr>
<tr><td style="width: 100px;"><strong>Data Storage Technique</strong></td>
    <td style="width: 238px;">Schema-free collections are utilized to store different 
        typesand document structures, such as {"color", "blue"} and {"price", "23.5"} 
        can be stored within a single collection.</td>
    <td style="width: 274px;">No collections are used for data storage; instead use 
        DML for it.</td></tr>
</tbody>
</table>

<p><strong>CAP Theorem</strong></p>

<p>The following guarantees are not available in a distributed system, as per the CAP 
theorem:</p>

<ul>
  <li><strong>Consistency </strong>- All nodes view the same data at the same time. 
      Data in the database remains consistent after the execution of an operation..</li>
  <li><strong>Availability </strong>- A guarantee that every request receives a response 
      about whether it was successful or failed. In other words the system is always up 
      with no downtime.</li>
  <li><strong>Partition Tolerance </strong>- The system continues to operate despite 
      failure of part of the system. The servers may be partitioned into multiple groups 
      that cannot communicate with every other group. The network can break into two or 
      more parts, each with active systems that cannot influence other parts.</li>
</ul>

<p>CAP provides the basic requirements for a distributed system to follow 2 of 
the 3 requirements. To scale out, you have to partition.</p>

<p>NoSQL database follows different combinations of the CAP theorem. Here is an 
elaborate description of 3 such combinations::</p> 
<img src="https://www.3pillarglobal.com/sites/default/files/nosql2.png" 
alt="CAP Theorem">

<UL>
  <LI><strong>CA -</strong>&nbsp;All nodes will remain in contact as a result of the 
      single site cluster and any partition will block the system.</p>

  <LI><strong>CP -</strong> Under this arrangement, some data might not be accessible 
      but consistency and accuracy are not compromised. There is no need for distributed 
      concurrency control as well..</p>

  <LI><strong>AP -</strong>&nbsp;With the AP approach, the returned data might not be 
      accurate but system will be available in spite of any partitioning. &nbsp;This is 
      best suited for replication needs and fault tolerance.</p>
</UL>

<p>In the next post on NoSQL databases, we will explore the different categories of 
NoSQL databases that are most popular with software developers today.</p> 

<a href="https://www.3pillarglobal.com/author/gkumar"><img alt="Girish Kumar" 
src="https://www.3pillarglobal.com/wp-content/uploads/2014/08/Girish-Kumar_avatar_1407240845-80x80.jpg" height="80" width="80"></a></div></div>

<h4>Girish Kumar</h4>

<h5>Technical Lead</h5>

<p></p>

<p>Girish Kumar is a Technical Lead at 3Pillar Global and the head of our Java 
Competency Center in India. He has been working in the Java domain for over 8 
years and has gained rich expertise in a wide array of Java technologies including 
Spring, Hibernate and Web Services. In addition, he has good exposure in 
implementation of complete SDLC using Agile and TDD methodology. Prior to joining 
3Pillar Global, Girish was working with Cognizant Technology Solutions for more 
than 5 years. Over there he has worked for some of the biggest names in the Banking 
and Finance verticals in U.S. &amp; U.K.</p>

<p>Girish's current challenges at 3Pillar include getting the best out of Apache 
Hadoop, NoSQL and distributed systems. He provides day-to-day leadership to the 
members of the Java Competency Center in India by enforcing best practices and 
providing technical guidance in key projects.</p>

<p></p>

<h5 id="comments"><span>3</span> Responses to "Just Say Yes to NoSQL Part i"</h5>

<ol>
  <li><div id="comment-40873">

<header> <cite><a href="http://gharbi-adlen.com/">Adlen G.</a></cite> on <time datetime="2015-02-28"><a href="https://www.3pillarglobal.com/insights/just-say-yes-to-nosql#comment-40873"> February 28th, 2015 - 11:28am </a></time></header>

<p>Great article, it really helped us to switch to NoSQL</p></div> </div></li>
  <li><div id="comment-65516">

<header> <cite>Adarsh</cite> on <time datetime="2015-08-14"><a href="https://www.3pillarglobal.com/insights/just-say-yes-to-nosql#comment-65516"> August 14th, 2015 - 2:31am </a></time></header>

<p>helpful</p></div> </div></li>
  <li><div id="comment-122737">

<header> <cite>Santo</cite> on <time datetime="2016-11-2"><a href="https://www.3pillarglobal.com/insights/just-say-yes-to-nosql#comment-122737"> November 2nd, 2016 - 11:19am </a></time></header>

<p>Great article.. thanks for putting the details together</p></div> </div></li>
</ol><section id="respond">

<a name="ExploringDifferentTypesNoSQL"></a>
<h3>Exploring the Different Types of NoSQL Databases Part ii 
<a href="https://www.3pillarglobal.com/insights/exploring-the-different-types-of-nosql-databases" 
target="_b">(Source Origin)</a></h3>

</div>

<p>In
 our previous post titled 'Just Say Yes to NoSQL', we cited the CAP 
theorem, did a point-by-point comparison between RDBMS and NoSQL and 
explored in-depth, the various characteristics of NoSQL which make it 
the most reliable database solution available today.</p>

<p>In this second part of the 3-part series we will focus exclusively on the different types of NoSQL databases.</p>

<p><strong>Types of NoSQL databases- </strong></p>

<p>There are 4 basic types of NoSQL databases:</p>

<ol>
  <li><strong>Key-Value Store</strong> - It has a Big Hash Table of keys &amp; values 
      {Example- Riak, Amazon S3 (Dynamo)}</li>
  <li><strong>Document-based Store</strong> - It stores documents made up of tagged 
      elements. {Example- CouchDB}</li>
  <li><strong>Column-based Store</strong> - Each storage block contains data from only 
      one column, {Example- HBase, Cassandra}</li>
  <li><strong>Graph-based Store</strong> - A network database that uses edges and nodes 
      to represent and store data. {Example- Neo4J}</li>
</ol>

<p>1.&nbsp;&nbsp;&nbsp;&nbsp; <strong>Key Value Store NoSQL Database</strong></p>

<p>The schema-less format of a key value database like Riak is just about what you need 
for your storage needs. The key can be synthetic or auto-generated while the value can 
be String, JSON, BLOB (basic large object) etc.</p>

<p>The key value type basically, uses a hash table in which there exists a unique key 
and a pointer to a particular item of data. A bucket is a logical group of keys - but 
they don't physically group the data. There can be identical keys in different 
buckets.</p>

<p>Performance is enhanced to a great degree because of the cache mechanisms that 
accompany the mappings. To read a value you need to know both the key and the bucket 
because the real key is a hash (Bucket + Key).</p>

<p>There
 is no complexity around the Key Value Store database model as it can be
 implemented in a breeze. Not an ideal method if you are only looking to
 just update part of a value or query the database.</p>

<p>When we try 
and reflect back on the CAP theorem, it becomes quite clear that key 
value stores are great around the Availability and Partition aspects but
 definitely lack in Consistency.</p>

<p>Example: Consider the data subset
 represented in the following table. Here the key is the name of the 
3Pillar country name, while the value is a list of addresses of 3PiIllar
 centers in that country.</p>

<table style="width: 650px;" cellpadding="1" cellspacing="1" border="1"><tbody>
<tr><td><strong>Key</strong></td>
    <td><strong>Value</strong></td></tr>
<tr><td>"India"</td>
    <td>{"B-25, Sector-58, Noida, India - 201301"}</td></tr>
<tr><td>"Romania"</td>
    <td>{"IMPS
 Moara Business Center, Buftea No. 1, Cluj-Napoca, 400606",City Business
 Center, Coriolan Brediceanu No. 10, Building B, Timisoara, 300011"}</td></tr>
<tr><td>"US"</td>
    <td>{"3975 Fair Ridge Drive. Suite 200 South, Fairfax, VA 22033"}</td></tr></tbody>
</table>

<p>The key can be synthetic or auto-generated while the value can be String, JSON, BLOB (basic large object) etc.</p>

<p>This key/value type database allow clients to read and write values using a key as follows:</p>

<ul>
  <li>Get(key), returns the value associated with the provided key.</li>
  <li>Put(key, value), associates the value with the key.</li>
  <li>Multi-get(key1, key2, .., keyN), returns the list of values associated with the list of keys.</li>
  <li>Delete(key), removes the entry for the key from the data store.</li>
</ul>

<p>While
 Key/value type database seems helpful in some cases, but it has some 
weaknesses as well. One, is that the model will not provide any kind of 
traditional database capabilities (such as atomicity of transactions, or
 consistency when multiple transactions are executed simultaneously). 
Such&nbsp; capabilities must be provided by the application itself.</p>

<p>Secondly,
 as the volume of data increases, maintaining unique values as keys may 
become more difficult; addressing this issue requires the introduction 
of some complexity in generating character strings that will remain 
unique among an extremely large set of keys.</p>

<ul>
  <li>Riak and <a href="http://en.wikipedia.org/wiki/Amazon_DynamoDB" 
      target="_blank">Amazon's Dynamo</a> are the most popular key-value store NoSQL 
      databases. See also: <a href="./AmazonDynamoATD.html#DynamoKeyValueStore" 
      target="_b">Dynamo: Amazon's Highly Available Key-value Store</a></li>
</ul>

<p>2.&nbsp;&nbsp;&nbsp;&nbsp; <strong>Document Store NoSQL Database</strong></p>

<p>The data which is a collection of key value pairs is compressed as a document store 
quite similar to a key-value store, but the only difference is that the values stored 
(referred to as "documents") provide some structure and encoding of the managed data. 
XML, JSON (Java Script Object Notation), BSON (which is a binary encoding of JSON 
objects) are some common standard encodings.</p>

<p>The following example
 shows data values collected as a "document" representing the names of 
specific retail stores. Note that while the three examples all represent
 locations, the representative models are different.</p><div id="highlighter_500584">

<table cellpadding="0" cellspacing="0" border="0"><tbody>
<tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div></td>
    <td><div>&nbsp</div><div>&nbsp</div><div>&nbsp</div><div>&nbsp</div><div>&nbsp</div><div>&nbsp</div><div>&nbsp</div><div>&nbsp</div><div>&nbsp</div></td>
    <td><div><div><code>{officeName:"3Pillar Noida", </code></div><div><code>{Street: "B-</code><code>25</code><code>, City:"Noida", State:"UP", Pincode:"</code><code>201301</code><code>"}</code></div><div><code>}</code></div><div><code>{officeName:"3Pillar Timisoara",</code></div><div><code>{Boulevard:"Coriolan Brediceanu No. </code><code>10</code><code>", Block:"B, Ist Floor", City: "Timisoara", Pincode: </code><code>300011</code><code>"}</code></div><div><code>}</code></div><div><code>{officeName:"3Pillar Cluj",</code></div><div><code>{Latitude:"</code><code>40.748328</code><code>", Longitude:"-</code><code>73.985560</code><code>"}</code></div><div><code>}</code></div></div></td></tr></tbody>
</table>


<p>One
 key difference between a key-value store and a document store is that 
the latter embeds attribute metadata associated with stored content, 
which essentially provides a way to query the data based on the 
contents. For example, in the above example, one could search for all 
documents in which "City" is "Noida" that would deliver a result set 
containing all documents associated with any "3Pillar Office" that is in
 that particular city.</p>

<p><a href="http://en.wikipedia.org/wiki/CouchDB" target="_blank">Apache CouchDB</a> is an example of a document store. CouchDB uses <a href="http://en.wikipedia.org/wiki/JSON" target="_blank">JSON</a> to store data, <a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a> as its query language using <a href="http://en.wikipedia.org/wiki/MapReduce">MapReduce</a> and <a href="http://en.wikipedia.org/wiki/HTTP" target="_blank">HTTP</a> for an <a href="http://en.wikipedia.org/wiki/API" target="_blank">API</a>.
 &nbsp;Data and relationships are not stored in tables as is a norm with conventional 
relational databases but in fact are a collection of independent documents. 
See also: <a href="./ExploringCouchDB.html" target="_b">Exploring CouchDB</a></p>

<p>The fact that document style databases are 
schema-less makes adding fields to JSON documents a simple task without 
having to define changes first.</p>

<ul>
  <li>Couchbase and MongoDB are the most popular document based databases.</li>
</ul>

<p>3.&nbsp;&nbsp;&nbsp;&nbsp; <strong>Column Store NoSQL Database</strong>-</p>

<p>In
 column-oriented NoSQL database, data is stored in cells grouped in 
columns of data rather than as rows of data. Columns are logically 
grouped into column families. Column families can contain a virtually 
unlimited number of columns that can be created at runtime or the 
definition of the schema. Read and write is done using columns rather 
than rows.</p>

<p>In comparison, most relational DBMS store data in rows,
 the benefit of storing data in columns, is fast search/ access and data
 aggregation. Relational databases store a single row as a continuous 
disk entry. Different rows are stored in different places on disk while 
Columnar databases store all the cells corresponding to a column as a 
continuous disk entry thus makes the search/access faster.</p>

<p>For 
example: &nbsp;&nbsp;To query the titles from a bunch of a million 
articles will be a painstaking task while using relational databases as 
it will go over each location to get item titles. On the other hand, 
with just one disk access, title of all the items can be obtained.</p>

<p><strong>Data Model </strong></p>

<ul>
  <li><strong>ColumnFamily</strong>: &nbsp;ColumnFamily is a single structure that can group Columns and SuperColumns with ease.</li>
  <li><strong>Key</strong>: the permanent name of the record. Keys have different numbers of columns, so the database can scale in an irregular way.</li>
  <li><strong>Keyspace</strong>:
 &nbsp;This defines the outermost level of an organization, typically 
the name of the application. For example, '3PillarDataBase' (database 
name).</li>
  <li><strong>Column</strong>: &nbsp;It has an ordered list of elements aka tuple with a name and a value defined.</li>
</ul>

<p>The best known examples are Google's BigTable and HBase &amp; Cassandra that were inspired from BigTable.</p>

<p>BigTable,
 for instance is a high performance, compressed and proprietary data 
storage system owned by Google. It has the following attributes:</p>

<ul>
  <li><strong>Sparse </strong>- some cells can be empty</li>
  <li><strong>Distributed </strong>- data is partitioned across many hosts</li>
  <li><strong>Persistent </strong>- stored to disk</li>
  <li><strong>Multidimensional </strong>- more than 1 dimension</li>
  <li><strong>Map </strong>- key and value</li>
  <li><strong>Sorted </strong>- maps are generally not sorted but this one is</li>
</ul>

<p>A 2-dimensional table comprising of rows and columns is part of the relational database system.</p>

<table style="width: 500px;" cellpadding="1" cellspacing="1" border="1"><tbody>
<tr><td><strong>City</strong></td>
    <td><strong>Pincode</strong></td>
    <td><strong>Strength</strong></td>
    <td><strong>Project</strong></td></tr>
<tr><td>Noida</td>
    <td>201301</td>
    <td>250</td>
    <td>20</td></tr>
<tr><td>Cluj</td>
    <td>400606</td>
    <td>200</td>
    <td>15</td></tr>
<tr><td>Timisoara</td>
    <td>300011</td>
    <td>150</td>
    <td>10</td></tr>
<tr><td>Fairfax</td>
    <td>VA 22033</td>
    <td>100</td>
    <td>5</td></tr></tbody>
</table>

<p>For above RDBMS table a BigTable map can be visualized as shown below.</p><div id="highlighter_855947">

<table cellpadding="0" cellspacing="0" border="0"><tbody>
<tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div></td>
    <td><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div></td>
    <td><div><div><code>{</code></div><div><code>3PillarNoida: {</code></div><div><code>city: Noida</code></div><div><code>pincode: </code><code>201301</code></div><div><code>},</code></div><div><code>details: {</code></div><div><code>strength: </code><code>250</code></div><div><code>projects: </code><code>20</code></div><div><code>}</code></div><div><code>}</code></div><div><code>{</code></div><div><code>3PillarCluj: {</code></div><div><code>address: {</code></div><div><code>city: Cluj</code></div><div><code>pincode: </code><code>400606</code></div><div><code>}, </code></div><div><code>details: {</code></div><div><code>strength: </code><code>200</code></div><div><code>projects: </code><code>15</code></div><div><code>}</code></div><div><code>},</code></div><div><code>{</code></div><div><code>3PillarTimisoara: {</code></div><div><code>address: {</code></div><div><code>city: Timisoara</code></div><div><code>pincode: </code><code>300011</code></div><div><code>},</code></div><div><code>details: {</code></div><div><code>strength: </code><code>150</code></div><div><code>projects: </code><code>10</code></div><div><code>}</code></div><div><code>}</code></div><div><code>{</code></div><div><code>3PillarFairfax : {</code></div><div><code>address: {</code></div><div><code>city: Fairfax</code></div><div><code>pincode: VA </code><code>22033</code></div><div><code>}, </code></div><div><code>details: {</code></div><div><code>strength: </code><code>100</code></div><div><code>projects: </code><code>5</code></div><div><code>}</code></div><div><code>}</code></div></div></td></tr></tbody>
</table>

</div></div>

<ul>
  <li>The outermost keys 3PillarNoida, 3PillarCluj, 3PillarTimisoara and 3PillarFairfax are analogues to rows.</li>
  <li>'address' and 'details' are called <strong>column families</strong>.</li>
  <li>The column-family 'address' has <strong>columns </strong>'city' and 'pincode'.</li>
  <li>The column-family details' has <strong>columns </strong>'strength' and 'projects'.</li>
</ul>

<p>Columns can be referenced using CloumnFamily.</p>

<ul>
  <li>Google's BigTable, HBase and Cassandra are the most popular column store based databases.</li>
</ul>

<p>4.&nbsp;&nbsp;&nbsp;&nbsp; <strong>Graph Base NoSQL Database</strong></p>

<p>In
 a Graph Base NoSQL Database, you will not find the rigid format of SQL 
or the tables and columns representation, a flexible graphical 
representation is instead used which is perfect to address scalability 
concerns. Graph structures are used with edges, nodes and properties 
which provides index-free adjacency. Data can be easily transformed from
 one model to the other using a Graph Base NoSQL database.</p> <img style="width: 300px; height: 372px;" src="https://www.3pillarglobal.com/sites/default/files/nosql-2c.png" alt="Graph Base NoSQL database">

<ul>
  <li>These databases that uses edges and nodes to represent and store data.</li>
  <li>These nodes are organised by some relationships with one another, which is represented by edges between the nodes.</li>
  <li>Both the nodes and the relationships have some defined properties.</li>
</ul>

 <img src="https://www.3pillarglobal.com/sites/default/files/nosql-2d.png" alt="graph based database">

<p>The following are some of the features of the graph based database, which are explained on the basis of the example below:</p>

<p>Labeled,
 directed, attributed multi-graph : The graphs contains the nodes which 
are labelled properly with some properties and these nodes have some 
relationship with one another which is shown by the directional edges. 
For example: in the following representation, "Alice knows Bob"&nbsp; is
 shown by an edge that also has some properties.</p>

<p>While relational database models can replicate the graphical ones, the edge would require a join which is a costly proposition.</p>

<p><img src="https://www.3pillarglobal.com/sites/default/files/nosql-2e.png" alt="database models"><br> <strong>UseCase</strong>-</p>

<p>Any
 'Recommended for You' rating you see on e-commerce websites (book/video
 renting sites) is often derived by taking into account how other users 
have rated the product in question. Arriving at such a UseCase is made 
easy using Graph databases.</p>

<p><a href="http://infogrid.org/" target="_blank">InfoGrid</a> and <a href="http://www.infinitegraph.com/" target="_blank">Infinite Graph</a>
 are the most popular graph based databases. &nbsp;InfoGrid allows the 
connection of as many edges (Relationships) and nodes (MeshObjects), 
making it easier to represent hyperlinked and complex set of 
information.</p>

<p>There are two kinds of GraphDatabase offered by InfoGrid, these include the following:</p>

<p><a href="http://infogrid.org/trac/wiki/MeshBase" target="_blank">MeshBase</a>- &nbsp;&nbsp;It is a perfect option where standalone deployment is required.</p>

<p><a href="http://infogrid.org/trac/wiki/NetMeshBase" target="_blank">NetMeshBase</a>
 - It is ideally suited for large distributed graphs and has additional 
capabilities to communicate with other similar NetMeshbase.</p>

<p>This 
concludes the second post exemplifying the value in a NoSQL 
implementation. In this blog post we discussed in detail the different 
types of NoSQL databases. Watch out for the concluding part of the 
series which will cover important factors to consider before finalizing 
which NoSQL database to use.</p></div><div><div><div> <a href="https://www.3pillarglobal.com/author/gkumar"></a></div><div>

<h4>Girish Kumar</h4>

<h5>Technical Lead</h5>

<p></p>

<p>Girish
 Kumar is a Technical Lead at 3Pillar Global and the head of our Java 
Competency Center in India. He has been working in the Java domain for 
over 8 years and has gained rich expertise in a wide array of Java 
technologies including Spring, Hibernate and Web Services. In addition, 
he has good exposure in implementation of complete SDLC using Agile and 
TDD methodology. Prior to joining 3Pillar Global, Girish was working 
with Cognizant Technology Solutions for more than 5 years. Over there he
 has worked for some of the biggest names in the Banking and Finance 
verticals in U.S. &amp; U.K.</p>

<p>Girish's current challenges at 
3Pillar include getting the best out of Apache Hadoop, NoSQL and 
distributed systems. He provides day-to-day leadership to the members of
 the Java Competency Center in India by enforcing best practices and 
providing technical guidance in key projects.</p>

<p></p></div></div></div></div><div>

<h5 id="comments"><span>5</span> Responses to "Exploring the Different Types of NoSQL Databases Part ii"</h5>

<ol>
  <li><div id="comment-1733">

<header> <cite>BD</cite> on <time datetime="2014-08-17"><a href="https://www.3pillarglobal.com/insights/exploring-the-different-types-of-nosql-databases#comment-1733"> August 17th, 2014 - 7:36pm </a></time></header><div>

<p>Very helpful. Thanks!</p></div> </div></li>
  <li><div id="comment-50250">

<header> <cite>Rohit</cite> on <time datetime="2015-05-1"><a href="https://www.3pillarglobal.com/insights/exploring-the-different-types-of-nosql-databases#comment-50250"> May 1st, 2015 - 10:42pm </a></time></header><div>

<p>Good Consolidation at one page and neat read.</p></div> </div></li>
  <li><div id="comment-52500">

<header> <cite>Mohammed</cite> on <time datetime="2015-05-14"><a href="https://www.3pillarglobal.com/insights/exploring-the-different-types-of-nosql-databases#comment-52500"> May 14th, 2015 - 3:48pm </a></time></header><div>

<p>Thank you  so much for this article,<br> I have a little question about Graph databases , why u don't talk about OrientDB or Neo4j ?<br>
 I know that the goal of your artcile is just explain the difference 
between each model (type) of nosql database. But what u think about this
 two technologies ?</p>

<p>Thank you.</p></div> </div></li>
  <li><div id="comment-83734">

<header> <cite>Manas</cite> on <a href="https://www.3pillarglobal.com/insights/exploring-the-different-types-of-nosql-databases#comment-83734">December 
23rd, 2015 - 9:09am</a></header><div>

<p>Girish,</p>

<p>Good article on NoSQL databases.</p>

<p>I have one query: What are differences between Document databases and Key-Value 
pair databases?</p></div> </div></li>
  <li><div id="comment-88191">

<header> <cite><a href="http://tuinsomniacorp.com/">Angel Banuelos</a></cite> on 
<a href="https://www.3pillarglobal.com/insights/exploring-the-different-types-of-nosql-databases#comment-88191"> February 
10th, 2016 - 12:53am </a></header><div>

<p>Very helpful!.</p>

<p>Well Distributed with nice examples and comparisons.</p>

<p>Thanks</p></div> </div></li>
</ol><section id="respond">


<a name="SelectionCriteriaNoSQLDatabase"></a>
<h3>Selection Criteria for NoSQL Database part iii 
<a href="https://www.3pillarglobal.com/insights/selection-criteria-for-nosql-database" 
target="_b">(Source Origin)</a></h3>

</div><div>

<p>In the <a href="http://www.3pillarglobal.com/insights/just-say-yes-to-nosql">first 
part</a> of this blog series we discussed about the reasons in support of NoSQL 
databases vis-a-vis relational databases. The <a href="http://www.3pillarglobal.com/insights/exploring-the-different-types-of-nosql-databases">second 
part</a><a href="https://www.3pillarglobal.com/blog/exploring-different-types-nosql-databases" 
target="_blank"><span style="display: none;">&nbsp;</span></a>
 grappled with the various types of NoSQL databases. Here we are back 
again, with the third and concluding part that will delve deep into the 
'Selection Criteria for NoSQL Database.'</p>

<p>Let's cut to the chase 
and give you the all important factors that you need to take into 
account before finalizing which NoSQL database is right for your needs:</p>

<p>1.&nbsp;&nbsp;&nbsp; <strong>Storage Type -</strong> A good indicator towards 
making the right choice of NoSQL database is its storage type.</p>

<ul>
  <li>For instance, get, put and delete functions are best supported by Key Value 
      systems.</li>
  <li>Aggregation becomes much easier while using Column oriented systems as against the 
      conventional row oriented databases. They use tables but do not have joins.</li>
  <li>Mapping data becomes easy from object oriented software using a Document oriented 
      NoSQL database such as XML or JSON as they use structure document formats.</li>
  <li>Tabular format is replaced and data is stored in graphical format.</li>
</ul>

<p>2.&nbsp;&nbsp;&nbsp; <strong>Concurrency Control- </strong>Concurrency
 control are what defines how two users can simultaneously edit the same
 bit of information. It happens quite often that one of the user is 
locked out and is unable to edit or perform other actions till the 
active user has finished editing.</p>

<ul>
  <li><strong>Locks</strong> prevent more than one active user to edit an entity such 
      as a document, row or an object.</li>
  <li><strong>MVCC</strong> (<strong>Multi-Version Concurrency Control)</strong>,
      guarantee a read consistent view of the database, but result in conflicting 
      versions of an entity if multiple users modify it at once. MVCC makes it possible 
      for a transaction to seamlessly go through by maintaining many different versions 
      of the object. That means transaction consistency is maintained even if that shows 
      varying snapshots to different users at any given point in time. Any changes made 
      to the database will be shown to others depending which snapshot are they 
      referring to.</li>
  <li><strong>None - </strong>Atomicity is missing in some systems thereby not providing 
      the same view of the database to multiple users editing the database. </li>
  <li><strong>ACID - </strong>For
 reliable database transactions, ACID or Atomicity, Consistency, 
Isolation, Durability is a safe bet. It allows for pre-screening 
transactions to avoid conflicts with no deadlocks.</li>
</ul>

<p>3.&nbsp;&nbsp;&nbsp; <strong>Replication - </strong>Replication ensures that mirror 
copies are always in sync.</p>

<ul>
  <li><strong>Synchronous Mode - </strong>Though
 it is an expensive approach as there is a dependency on the second 
server to respond, but it always ensures consistency. After receiving 
response from the second server, the first server sends back the ACK to 
the client. This ensures data is placed in multiple nodes at the same 
time.</li>
  <li><strong>Asynchronous mode- </strong>In this mode, one 
database gets updated without waiting for the answer from the other 
database.Two databases could be not consistent in the range of few 
milliseconds. &nbsp;This should explain why this cost-effective and 
synchronous replication method is also dubbed as 'Eventaully 
Consistent.'</li>
</ul>

<p>4.&nbsp;&nbsp;&nbsp; <strong>Implementation Language- </strong>Implementation
 language helps to determine how fast a database will process. Typically
 NoSQL databases written in low level languages such as C/C++ and Erlang
 will be the fastest. On the other hand, those written in higher level 
languages such as Java make customizations easier.</p>

<h3><strong>Comparison of NoSQL databases</strong></h3>

<p><strong>Comparison by Data (Size &amp; Complexity)</strong></p> 

<img src="https://www.3pillarglobal.com/sites/default/files/nosql-3a.png" style="height: 
449px; width: 600px;" alt="NOSQL data models">

<p><strong>Comparison by Type</strong></p>

<table style="width: 590px;" cellpadding="1" cellspacing="1" border="1"><tbody>
<tr><td><strong>Category</strong></td>
    <td style="width: 338px;"><strong>Description</strong></td>
    <td style="width: 175px;"><strong>Name of the Database</strong></td></tr>
<tr><td>Document Oriented</td>
    <td style="width: 338px;">Data is stored as documents. An example format is 
        FirstName="Arun", Address="St. Xavier's Road", Spouse=[{Name:"Kiran"}], 
        Children=[{Name:"Rohit", Age: 8}]</td>
    <td style="width: 175px;">CouchDB, Jackrabbit, MongoDB, OrientDB, simpleDB, 
        Terrastore, etc.</td></tr>
<tr><td>XML Database</td>
    <td style="width: 338px;">Data is stored in XML format</td>
    <td style="width: 175px;">BaseX, eXist, MarkLogic Server, etc.</td></tr>
<tr><td>Graph databases</td>
    <td style="width: 338px;">Data is stored as a collection of nodes, where nodes are 
        analogous to objects in a programming language. Nodes are connected using 
        edges.</td>
    <td style="width: 175px;">AllegroGraph, DEX, Neo4j, FlockDB, Sones GraphDB, 
        etc.</td></tr>
<tr><td>Key-value store</td>
    <td style="width: 338px;">In Key-value store category of NoSQL database, a user can 
        store data in a schema-less way. A key may be strings, hashes, lists, sets, 
        sorted sets and values are stored against these keys.</td>
    <td style="width: 175px;">Cassandra, Riak, Redis, memcached, Big Table, 
        etc.</td></tr></tbody>
</table>

<p><strong>Detailed Comparison</strong></p>

<table style="width: 650px;" cellpadding="1" cellspacing="1" border="1"><tbody>
<tr><td><strong>Store</strong></td>
    <td><strong>Name</strong></td>
    <td><strong>API</strong></td>
    <td><strong>Protocol</strong></td>
    <td style="width: 158px;"><strong>Query Method</strong></td>
    <td style="width: 4px;"><strong>Replication</strong></td>
    <td style="width: 91px;"><strong>Written In</strong></td>
    <td style="width: 137px;"><strong>CAP Characteristics</strong></td></tr>
<tr><td>Key Value</td>
    <td>Riak</td>
    <td>Json</td>
    <td>REST</td>
    <td style="width: 158px;">MapReduce</td>
    <td style="width: 4px;">Async</td>
    <td style="width: 91px;">Erlang</td>
    <td style="width: 137px;">High Availability, Partition, Tolerance, 
        Persistence</td></tr>
<tr><td>Key Value</td>
    <td>MemcachedDB</td>
    <td>C, Python</td>
    <td>Memcache protocol</td>
    <td style="width: 158px;">Memcache pattern</td>
    <td style="width: 4px;">No</td>
    <td style="width: 91px;">C, Python</td>
    <td style="width: 137px;">Consistency, Partition, Tolerance</td></tr>
<tr><td>Column</td>
    <td>HBase</td>
    <td>Java</td>
    <td>Any Write Call</td>
    <td style="width: 158px;">MapReduce</td>
    <td style="width: 4px;">HDFS</td>
    <td style="width: 91px;">Java</td>
    <td style="width: 137px;">Consistency, Partition, Tolerance, Persistence</td></tr>
<tr><td>Column</td>
    <td>Casandra</td>
    <td>CQL and Thrift</td>
    <td>Thrift</td>
    <td style="width: 158px;">Casandra query language</td>
    <td style="width: 4px;">Peer-to-Peer</td>
    <td style="width: 91px;">Java</td>
    <td style="width: 137px;">High Availability Partition, Tolerance, 
        Persistence</td></tr>
<tr><td>Document</td>
    <td>MongoDB</td>
    <td>BSON</td>
    <td>C</td>
    <td style="width: 158px;">Dynamic object based language &amp; MapReduce</td>
    <td style="width: 4px;">Master Slave &amp; Auto-Sharding</td>
    <td style="width: 91px;">C++</td>
    <td style="width: 137px;">Consistency, Partition, Tolerance, Persistence</td></tr>
<tr><td>Document</td>
    <td>CouchBase</td>
    <td>Memcached</td>
    <td>Memcached REST interface for cluster configuration</td>
    <td style="width: 158px;">Javascript</td>
    <td style="width: 4px;">Peer-to-Peer</td>
    <td style="width: 91px;">C, C++, Erlang</td>
    <td style="width: 137px;">Consistency, High Availability, Persistence</td></tr>
<tr><td>GraphBase</td>
    <td>Info Grid</td>
    <td>Java</td>
    <td>OpenID, RSS, Atom, JSON, Java embedded</td>
    <td style="width: 158px;">Web user interface with HTML, RSS, Atom, JSON output, 
        Java native</td>
    <td style="width: 4px;">Peer-to-Peer</td>
    <td style="width: 91px;">Java</td>
    <td style="width: 137px;">High Availability, Partition, Tolerance</td></tr>
<tr><td>GraphBase</td>
    <td>Infinite Graph</td>
    <td>Java</td>
    <td>Direct Language Binding</td>
    <td style="width: 158px;">Graph Navigation API, Predicate Language Qualification</td>
    <td style="width: 4px;">Peer-to-Peer</td>
    <td style="width: 91px;">Java</td>
    <td style="width: 137px;">High Availability, Partition, Tolerance</td></tr></tbody>
</table>

<p><strong>Conclusion</strong></p>

<p>Here is another quick comparison between NoSQL and RDMS:</p>

<p><strong>Opt NoSQL</strong></p>

<p>1.&nbsp;&nbsp;&nbsp;&nbsp; If data is huge, unstructured, sparse/growing</p>

<p>2.&nbsp;&nbsp;&nbsp;&nbsp; Less rigid schema</p>

<p>3.&nbsp;&nbsp;&nbsp;&nbsp; Performance &amp; Availability preferred over 
     Redundancy</p>

<p>4.&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;While scaling out is an out-of-the-box feature, 
     it does not prevent scale up,</p>

<p>5.&nbsp;&nbsp;&nbsp;&nbsp; Cost Effective- uses clusters of cheap <a 
href="http://en.wikipedia.org/wiki/Commodity_computing"><em>commodity servers</em></a> 
to manage the exploding data and transaction volumes</p>

<p><strong>Opt RDBMS</strong></p>

<p>1.&nbsp;&nbsp;&nbsp; If Analytics, BI or Reporting is required.</p>

<p>2.&nbsp;&nbsp;&nbsp;&nbsp; For Benefits of ACID</p>

<p>3.&nbsp;&nbsp;&nbsp;&nbsp; Rigid Schema</p>

<p>4.&nbsp;&nbsp;&nbsp;&nbsp; No redundancy allowed</p>

<p>5.&nbsp;&nbsp;&nbsp;&nbsp; Allows Scale up &amp; limited Scale-out (sharding)</p>

<p>6.&nbsp;&nbsp;&nbsp;&nbsp; Expensive- rely on expensive proprietary servers and 
     storage systems</p>

<p>This concludes our 3-part series on NoSQL and the merits in its adoption. We hope 
you liked reading it. Please leave us with your valuable comments in the box below.</p>

</div><div><div><div> <a href="https://www.3pillarglobal.com/author/gkumar"></a>
</div><div>

<h4>Girish Kumar</h4>

<h5>Technical Lead</h5>

<p></p>

<p>Girish
 Kumar is a Technical Lead at 3Pillar Global and the head of our Java 
Competency Center in India. He has been working in the Java domain for 
over 8 years and has gained rich expertise in a wide array of Java 
technologies including Spring, Hibernate and Web Services. In addition, 
he has good exposure in implementation of complete SDLC using Agile and 
TDD methodology. Prior to joining 3Pillar Global, Girish was working 
with Cognizant Technology Solutions for more than 5 years. Over there he
 has worked for some of the biggest names in the Banking and Finance 
verticals in U.S. &amp; U.K.</p>

<p>Girish's current challenges at 
3Pillar include getting the best out of Apache Hadoop, NoSQL and 
distributed systems. He provides day-to-day leadership to the members of
 the Java Competency Center in India by enforcing best practices and 
providing technical guidance in key projects.</p>

<p></p></div></div></div></div><div>

<h5 id="comments"><span>3</span> Responses to "Selection Criteria for NoSQL Database 
part iii"</h5>

<ol>
  <li><div id="comment-19938">

<header> <cite>Dinesh P</cite> on <a href="https://www.3pillarglobal.com/insights/selection-criteria-for-nosql-database#comment-19938"> November 
11th, 2014 - 3:42am </a></header><div>

<p>Good article. All the three parts were good and easy to understand</p></div> 
</div></li>
  <li><div id="comment-49139">

<header> <cite>leon shlimak</cite> on <a href="https://www.3pillarglobal.com/insights/selection-criteria-for-nosql-database#comment-49139"> April 
26th, 2015 - 8:22am </a></header><div>

<p>Great 3 blog posts. Helped me get my head around NoSQL. thanks :))</p>
</div> </div></li>
  <li><div id="comment-49144">

<header> <cite>ichard</cite> on <time datetime="2015-04-26"><a href="https://www.3pillarglobal.com/insights/selection-criteria-for-nosql-database#comment-49144"> April 26th, 2015 - 12:09pm </a></time></header><div>

<p>Nice set of articles that introduces a newbie to NoSQL...</p></div> </div></li>
</ol><section id="respond">

<A name="NoSQLDatabasesComparison"></a>
    <h3>
A Comparison Of NoSQL Database Management Systems And Models 
<a href="https://www.digitalocean.com/community/tutorials/a-comparison-of-nosql-database-management-systems-and-models" 
target="_b">(Source Origin)</a>
    </h3>

    <span>Posted February 21, 2014</span>

    <span>172.3k views</span>

    <span>
<a href="https://www.digitalocean.com/community/tags/nosql?type=tutorials">NoSQL</a> 
<a href="https://www.digitalocean.com/community/tags/mongodb?type=tutorials">MongoDB</a>
    </span>

   <h4 id="introduction">Introduction</h4>

<hr>

<p>NoSQL databases try to offer certain functionality that more traditional relational 
database management systems do not. Whether it is for holding simple key-value pairs 
for shorter lengths of time for caching purposes, or keeping unstructured collections 
(e.g. collections) of data that could not be easily dealt with using relational 
databases and the <em>structured query language</em> (SQL) - they are here to help.</p>

<p>In this DigitalOcean article, we are going to try to introduce you to various popular 
NoSQL database management systems and explain their purposes and functionality, so that 
you can decide which one to use, or if they even suit your application's needs -- 
<em>at all</em>.</p>

<h4 id="glossary">Table of Contents</h4>

<hr>

<h4 id="1-database-management-systems"><a href="#database-management-systems">1. 
Database Management Systems</a></h4>

<hr>

<h4 id="2-nosql-database-management-systems"><a 
href="#nosql-database-management-systems">2. NoSQL Database Management Systems</a></h4>

<hr>

<ol>
<li><a href="#key-value-based">Key / Value Based</a></li>
<li><a href="#column-based">Column Based</a></li>
<li><a href="#document-based">Document Based</a></li>
<li><a href="#graph-based">Graph Based</a></li>
</ol>

<h4 id="3-key-value-based-nosql-database-management-systems">
<a href="#key--value-based-nosql-database-management-systems">3. Key / Value Based 
NoSQL Database Management Systems</a></h4>

<hr>

<ol>
<li><a href="#popular-key-value-based-databases">Popular Key / Value Based 
Databases</a></li>
<li><a href="#when-to-use-key-value">When To Use</a></li>
</ol>

<h4 id="4-column-based-nosql-database-management-systems">
<a href="#column-based-nosql-database-management-systems">4. Column Based NoSQL 
Database Management Systems</a></h4>

<hr>

<ol>
<li><a href="#popular-column-based-databases">Popular Column Based Databases</a></li>
<li><a href="#when-to-use-column">When To Use</a></li>
</ol>

<h4 id="5-document-based-nosql-database-management-systems">
<a href="#document-based-nosql-database-management-systems">5. Document Based NoSQL 
Database Management Systems</a></h4>

<hr>

<ol>
<li><a href="#popular-document-based-databases">Popular Document Based Databases</a></li>
<li><a href="#when-to-use-document">When To Use</a></li>
</ol>

<h4 id="6-graph-based-nosql-database-management-systems">
<a href="#graph-based-nosql-database-management-systems">6. Graph Based NoSQL Database 
Management Systems</a></h4>

<hr>

<ol>
<li><a href="#popular-graph-based-databases">Popular Graph Based Databases</a></li>
<li><a href="#when-to-use-graph">When To Use</a></li>
</ol>

<h4 id="7-nosql-dbmss-in-comparison-to-relational-dbmss">
<a href="#nosql-dbmss-in-comparison-to-relational-dbmss">7. NoSQL DBMSs In Comparison 
To Relational DBMSs</a></h4>

<hr>

<ol>
<li><a href="#when-to-use-nosql-databases">When To Use NoSQL Databases</a></li>
</ol>

<a name="database-management-systems"></a>
<h4>Database Management Systems</h4>

<hr>

<p>Databases are logically modeled storage spaces for all kinds of 
different information (data). Each database, other than schema-less 
ones, have a model which provides structure for the data being dealt 
with. Database management systems are applications (or libraries) which 
manage databases of various shapes, sizes, and sorts.</p>

<p><strong>Note:</strong> To learn more about Database Management Systems, check out 
our article: <a href="http://link_to_10_1_understanding_databases/">Understanding 
Databases</a>.</p>

<a name="nosql-database-management-systems"></a>
<h4>NoSQL Database Management Systems</h4>

<hr>

<p>In the past decade or so, relational database management systems have
 been the choice of many developers and system administrators for a 
variety of applications, for a variety of reasons. Despite not being 
exactly flexible, the powerful nature of many RDBMS allowed complex 
database set-ups to be created, queried and used. This was more than 
enough for many requirements, since it was not until long ago that 
different needs started to rise.</p>

<p>The term "NoSQL" was coined over a decade ago, funnily enough as a 
name to yet-another relational database. However, this database had a 
different idea behind it: eliminating the use of the standardised SQL. 
In the next years to come, others picked up and continued to grow this 
thought, by referring to various other non-relational databases as <strong>NoSQL 
databases</strong>.</p>

<p>By design, NoSQL databases and management systems are relation-less (or schema-less). 
They are not based on a single model (e.g. <em>relational model</em> of RDBMSs) and each 
database, depending on their target-functionality, adopt a different one.</p>

<p>There are almost a handful of different operational models and functioning systems 
for NoSQL databases.:</p>

<ul>
<li><strong>Key / Value:</strong><br></li>
</ul>

<p>e.g. Redis, MemcacheDB, etc.</p>

<ul>
<li><strong>Column:</strong><br></li>
</ul>

<p>e.g. Cassandra, HBase, etc.</p>

<ul>
<li><strong>Document:</strong><br></li>
</ul>

<p>e.g. MongoDB, Couchbase, etc</p>

<ul>
<li><strong>Graph:</strong><br></li>
</ul>

<p>e.g. OrientDB, Neo4J, etc. </p>

<p>In order to better understand the roles and underlying technology of 
each database management system, let's quickly go over these four 
operational models.</p>

<h4 id="key-value-based">Key / Value Based</h4>

<hr>

<p>We will begin our NoSQL modeling journey with key / value based 
database management simply because they can be considered the most basic
 and backbone implementation of NoSQL.</p>

<p>These type of databases work by matching keys with values, similar to a dictionary. 
There is no structure nor relation. After connecting to the database server (e.g. 
Redis), an application can state a key (e.g. <code>the_answer_to_life</code>) and 
provide a matching value (e.g. <code>42</code>) which can later be retrieved the same 
way by supplying the key.</p>

<p>Key / value DBMSs are usually used for quickly storing basic 
information, and sometimes not-so-basic ones after performing, for 
example, a CPU and memory intensive computation. They are extremely 
performant, efficient and usually easily scalable.</p>

<p><strong>Note:</strong> When it comes to computers, a <em>dictionary</em>
 usually refers to a special sort of data object. They constitutes of 
arrays of collections with individual keys matching values.</p>

<h4 id="column-based">Column Based</h4>

<hr>

<p>Column based NoSQL database management systems work by advancing the simple nature 
of key / value based ones.</p>

<p>Despite their complicated-to-understand image on the internet, these 
databases work very simply by creating collections of one or more key / 
value pairs that match a record.</p>

<p>Unlike the traditional defines schemas of relational databases, 
column-based NoSQL solutions do not require a pre-structured table to 
work with the data. Each record comes with one or more columns 
containing the information and each column of each record can be 
different.</p>

<p>Basically, column-based NoSQL databases are two dimensional arrays 
whereby each key (i.e. row / record) has one or more key / value pairs 
attached to it and these management systems allow very large and 
un-structured data to be kept and used (e.g. a record with tons of 
information).</p>

<p>These databases are commonly used when simple key / value pairs are 
not enough, and storing very large numbers of records with very large 
numbers of information is a must. DBMS implementing column-based, 
schema-less models can scale extremely well.</p>

<h4 id="document-based">Document Based</h4>

<hr>

<p>Document based NoSQL database management systems can be considered the latest craze 
that managed to take <em>a lot</em> of people by storm. These DBMS work in a similar 
fashion to column-based ones; however, they allow much deeper nesting and complex 
structures to be achieved (e.g. a document, within a document, within a 
document).</p>

<p>Documents overcome the constraints of one or two level of key / value
 nesting of columnar databases. Basically, any complex and arbitrary 
structure can form a document, which can be stored using these 
management systems.</p>

<p>Despite their powerful nature, and the ability to query records by 
individual keys, document based management systems have their own issues
 and downfalls compared to others. For example, retrieving a value of a 
record means getting the whole lot of it and same goes for updates, all 
of which affect the performance.  </p>

<h4 id="graph-based">Graph Based</h4>

<hr>

<p>Finally, the very interesting flavour of NoSQL database management systems is the 
graph based ones.</p>

<p>The graph based DBMS models represent the data in a completely 
different way than the previous three models. They use tree-like 
structures (i.e. graphs) with nodes and edges connecting each other 
through relations.</p>

<p>Similarly to mathematics, certain operations are much simpler to 
perform using these type of models thanks to their nature of linking and
 grouping related pieces of information (e.g. connected people).</p>

<p>These databases are commonly used by applications whereby clear 
boundaries for connections are necessary to establish. For example, when
 you register to a social network of any sort, your friends' connection 
to you and their friends' friends' relation to you are much easier to 
work with using graph-based database management systems.  </p>

<a name="key--value-based-nosql-database-management-systems"></a>
<h4>Key / Value Based NoSQL 
Database Management Systems</h4>

<hr>

<p>Key / Value data stores are highly performant, easy to work with and they usually 
scale well.</p>

<h4 id="popular-key-value-based-databases">Popular Key / Value Based Databases</h4>

<hr>

<p>Some popular key / value based data stores are:</p>

<ul>
<li><strong>Redis:</strong><br></li>
</ul>

<p>In-memory K/V store with optional persistence.</p>

<ul>
<li><strong>Riak:</strong><br></li>
</ul>

<p>Highly distributed, replicated K/V store.</p>

<ul>
<li><strong>Memcached / MemcacheDB:</strong><br></li>
</ul>

<p>Distributed memory based K/V store.</p>

<h4 id="when-to-use-key-value">When To Use</h4>

<hr>

<p>Some popular use cases for key / value based data stores are:</p>

<ul>
<li><strong>Caching:</strong><br></li>
</ul>

<p>Quickly storing data for - sometimes frequent - future use.</p>

<ul>
<li><strong>Queue-ing:</strong><br></li>
</ul>

<p>Some K/V stores (e.g. Redis) supports lists, sets, queues and more.</p>

<ul>
<li><strong>Distributing information / tasks:</strong><br></li>
</ul>

<p>They can be used to implement <em>Pub/Sub</em>.</p>

<ul>
<li><strong>Keeping live information:</strong><br></li>
</ul>

<p>Applications which need to keep a <em>state</em> cane use K/V stores easily.   </p>

<a name="column-based-nosql-database-management-systems"></a>
<h4>Column Based NoSQL Database Management Systems</h4>

<hr>

<p>Column based data stores are extremely powerful and they can be 
reliably used to keep important data of very large sizes. Despite not 
being "flexible" in terms of what constitutes as data, they are highly 
functional and performant.</p>

<h4 id="popular-column-based-databases">Popular Column Based Databases</h4>

<hr>

<p>Some popular column based data stores are:</p>

<ul>
<li><strong>Cassandra:</strong><br></li>
</ul>

<p>Column based data store based on BigTable and DynamoDB.</p>

<ul>
<li><strong>HBase:</strong><br></li>
</ul>

<p>Data store for Apache Hadoop based on ideas from BigTable.</p>

<h4 id="when-to-use-column">When To Use</h4>

<hr>

<p>Some popular use cases for column based data stores are:</p>

<ul>
<li><strong>Keeping unstructured, non-volatile information:</strong><br></li>
</ul>

<p>If a large collection of attributes and values needs to be kept for 
long periods of time, column-based data stores come in extremely handy.</p>

<ul>
<li><strong>Scaling:</strong><br></li>
</ul>

<p>Column based data stores are highly scalable by nature. They can handle an awful 
amount of information.</p>

<a name="document-based-nosql-database-management-systems"></a>
<h4  id="document-based-nosql-database-management-systems">Document Based NoSQL Database 
Management Systems</h4>

<hr>

<p>Document based data stores are excellent for keeping a lot of 
unrelated complex information that is highly variable in terms of 
structure from one another.</p>

<h4 id="popular-document-based-databases">Popular Document Based Databases</h4>

<hr>

<p>Some popular document based data stores are:</p>

<ul>
<li><strong>Couchbase:</strong><br></li>
</ul>

<p>JSON-based, Memcached-compatible document-based data store.</p>

<ul>
<li><strong>CouchDB:</strong><br></li>
</ul>

<p>A ground-breaking document-based data store.</p>

<ul>
<li><strong>MongoDB:</strong><br></li>
</ul>

<p>An extremely popular and highly-functional database.</p>

<h4 id="when-to-use-document">When To Use</h4>

<hr>

<p>Some popular use cases for document based data stores are:</p>

<ul>
<li><strong>Nested information:</strong><br></li>
</ul>

<p>Document-based data stores allow you to work with deeply nested, complex data 
structures.</p>

<ul>
<li><strong>JavaScript friendly:</strong><br></li>
</ul>

<p>One of the most critical functionalities of document-based data 
stores are the way they interface with applications: Using JS friendly 
JSON.</p>

<a name="graph-based-nosql-database-management-systems"></a>
<h4>Graph Based NoSQL Database Management Systems</h4>

<hr>

<p>Graph based data stores offer a very unique functionality that is unmatched with 
any other DBMSs.</p>

<h4 id="popular-graph-based-databases">Popular Graph Based Databases</h4>

<hr>

<p>Some popular graph based data stores are:</p>

<ul>
<li><strong>OrientDB:</strong><br></li>
</ul>

<p>A very fast graph and document based hybrid NoSQL data store written in Java that 
comes with different operational modes.</p>

<ul>
<li><strong>Neo4J:</strong><br></li>
</ul>

<p>A schema-free, extremely popular and powerful Java graph based data store.</p>

<h4 id="when-to-use-graph">When To Use</h4>

<hr>

<p>Some popular use cases for graph based data stores are:</p>

<ul>
<li><strong>Handling complex relational information:</strong><br></li>
</ul>

<p>As explained in the introduction, graph databases make it extremely 
efficient and easy to use to deal with complex but relational 
information, such as the connections between two entities and various 
degrees of other entities indirectly related to them.</p>

<ul>
<li><strong>Modelling and handling classifications:</strong><br></li>
</ul>

<p>Graph databases excel in any situation where relationships are 
involved. Modelling data and classifying various information in a 
relational way can be handled very well using these type of data stores.</p>

<a name="nosql-dbmss-in-comparison-to-relational-dbmss"></a>
<h4>NoSQL DBMSs In Comparison To Relational DBMSs</h4>

<hr>

<p>In order to draw a clear picture of how NoSQL solutions differ from 
relational database management systems, let's create a quick comparison 
list:</p>

<h4 id="when-to-use-nosql-databases">When To Use NoSQL Databases</h4>

<hr>

<ul>
<li><strong>Size matters:</strong><br></li>
</ul>

<p>If will be working with very large sets of data, consistently scaling
 is easier to achieve with many of the DBMS from NoSQL family.</p>

<ul>
<li><strong>Speed:</strong><br></li>
</ul>

<p>NoSQL databases are usually faster - and sometimes extremely speedier - when it 
comes to <em>write</em>s. <em>Read</em>s can also be very fast depending on the type 
of NoSQL database and data being queried.</p>

<ul>
<li><strong>Schema-free design:</strong><br></li>
</ul>

<p>Relational DBMSs require structure from the beginning. NoSQL solutions offer a large 
amount of flexibility.</p>

<ul>
<li><strong>Automated (or easy) replications / scaling:</strong><br></li>
</ul>

<p>NoSQL databases are growing rapidly and they are being actively built <em>today</em>
 - vendors are trying to tackle common issues and one of them clearly is
 replication and scaling. Unlike RDBMSs, NoSQL solutions can easily 
scale and work with(in) clusters.</p>

<ul>
<li><strong>Multiple choices:</strong><br></li>
</ul>

<p>When it comes to choosing a NoSQL data store, there are a variety of 
models, as we have discussed, that you can choose from to get the most 
out of the database management system - depending on your data type.</p>

<div>Submitted by: <a href="https://twitter.com/ostezer">O.S. Tezer</a></div>

</body></html>
